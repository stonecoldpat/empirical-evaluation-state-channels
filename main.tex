\PassOptionsToPackage{usenames}{xcolor}
\PassOptionsToPackage{dvipsnames}{xcolor}
\documentclass{llncs}
\usepackage[utf8]{inputenc}
\usepackage{booktabs} % For formal tables
\usepackage{multirow}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{url}
\usepackage{xspace}
\usepackage{pifont}% http://ctan.org/pkg/pifont
\usepackage{color}
\usepackage{boxedminipage}
\usepackage[ff,sets,keys,primitives,operators]{cryptocode}
\usepackage{framed}
\usepackage[group-separator={,}]{siunitx}
\newcommand\bmmax{2}
\usepackage{bm}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{footnote}
\usepackage{units}
\usepackage{multicol,lipsum}
\colorlet{iomsg}{MidnightBlue}
\colorlet{party}{brown}
\colorlet{entry}{NavyBlue}
\colorlet{string}{BlueViolet}

\newcommand{\instantiated}{\mathsf{instantiated}}
\newcommand{\instantiatedno}{\mathsf{NO}}
\newcommand{\instantiatedyes}{\mathsf{YES}}


\newcommand{\gamestatus}{\mathsf{phase}}
\newcommand{\gameregister}{\mathsf{INIT}}
\newcommand{\gamesetup}{\mathsf{SETUP}}
\newcommand{\gameattack}{\mathsf{ATTACK}}
\newcommand{\gamereveal}{\mathsf{REVEAL}}
\newcommand{\gamewinner}{\mathsf{WIN}}
\newcommand{\gamefraud}{\mathsf{FRAUD}}
\newcommand{\gamefinished}{\mathsf{GAMEOVER}}

\newcommand{\chanstatus}{\mathsf{status}}

\newcommand{\chanon}{\mathsf{ON}}
\newcommand{\chandispute}{\mathsf{DISPUTE}}
\newcommand{\chanoff}{\mathsf{OFF}}

\newcommand{\hready}{\mathsf{hready}}
\newcommand{\hboard}{\mathsf{hboard}}
\newcommand{\hslot}{\mathsf{hslot}}
\newcommand{\hship}{\mathsf{hship}}
\newcommand{\hshiplocation}{\mathsf{hshiplocation}}

%\newcommand{\hash}{\textsf{H}}
\newcommand{\cmd}{\mathsf{cmd}}
\newcommand{\hstate}{\mathsf{hstate}}
\newcommand{\hstatei}{\mathsf{hstate}_{\monotoniccounter}}
\newcommand{\hstateplus}{\ensuremath{\mathsf{hstate}_{\monotoniccounter+1}}}
\newcommand{\hstateminus}{\ensuremath{\mathsf{hstate}_{\monotoniccounter-1}}}
\newcommand{\monotoniccounter}{\mathsf{i}}
\newcommand{\stateinfo}{\mathsf{state}}
\newcommand{\stateinfoi}{\mathsf{state}_{\mathsf{i}}}
\newcommand{\stateinfominus}{\mathsf{state}_{\mathsf{i-1}}}
\newcommand{\stateinfoplus}{\mathsf{state}_{\mathsf{i+1}}}
\newcommand{\participant}{\mathcal{P}}

\newcommand{\rani}{\mathsf{r}_{\mathsf{i}}}
\newcommand{\ran}{\mathsf{r}}
\newcommand{\ranminus}{\mathsf{r}_{\mathsf{i-1}}}
\newcommand{\ranplus}{\mathsf{r}_{\mathsf{i+1}}}

\newcommand{\statechannel}{\mathsf{SC}}
\newcommand{\statechanneldispute}{\mathsf{SC}.\mathsf{trigger}}
\newcommand{\statechannelsetstate}{\mathsf{SC}.\mathsf{setstatehash}}
\newcommand{\statechannelresolve}{\mathsf{SC}.\mathsf{resolve}} 
\newcommand{\statechannelgetcommitment}{\mathsf{SC}.\mathsf{getstatehash}} 
\newcommand{\statechannelgetdispute}{\mathsf{SC}.\mathsf{getdispute}} 

\newcommand{\sign}{\mathsf{Sign}}
\newcommand{\verifysig}{\mathsf{VerifySig}}

\newcommand{\battleship}{\mathsf{BS}}
\newcommand{\battleshipfraud}{\mathsf{BS.fraud}}
\newcommand{\battleshipattackslot}{\mathsf{BS.attackslot}}
\newcommand{\battleshipbegin}{\mathsf{BS.begingame}}
\newcommand{\battleshipcommit}{\mathsf{BS.setupcommit}}
\newcommand{\battleshipselectboard}{\mathsf{BS.setupselect}}
\newcommand{\battleshiprevealslot}{\mathsf{BS.revealslot}}
\newcommand{\battleshipsinking}{\mathsf{BS.sunk}}
\newcommand{\battleshiprevealboard}{\mathsf{BS.revealboard}}
\newcommand{\battleshipgameover}{\mathsf{BS.gameover}}

\newcommand{\battleshipadjacent}{\mathsf{BS.adjacentships}}
\newcommand{\battleshipnotstraightline}{\mathsf{BS.notstraightline}}
\newcommand{\battleshipshipnotplaced}{\mathsf{BS.shipnotplaced}}
\newcommand{\battleshipnotsunk}{\mathsf{BS.declarednotsunk}}

\newcommand{\appcontract}{\mathsf{AC}}
\newcommand{\applock}{\mathsf{AC.lock}}
\newcommand{\appunlock}{\mathsf{AC.unlock}}

\newcommand{\timerchallenge}{\mathsf{\Delta}_{\mathsf{challenge}}}
\newcommand{\timechallenge}{\mathsf{t}_{\mathsf{challenge}}}
\newcommand{\timerdispute}{\mathsf{\Delta}_{\mathsf{dispute}}}
\newcommand{\timenow}{\mathsf{t}_{\mathsf{now}}}
\newcommand{\timestart}{\mathsf{t}_{\mathsf{start}}}
\newcommand{\timeend}{\mathsf{t}_{\mathsf{end}}}
\newcommand{\timedispute}{\timenow + \mathsf{\Delta}_{\mathsf{dispute}}}

% Colorful diagrams 
\newcommand{\constructor}{\textcolor{entry}{\bf constructor }}
\newcommand{\oninput}{\textcolor{entry}{\bf function }}
\newcommand{\stringlitt}[1]{\texttt{\textcolor{string}{#1}}}

\begin{document}


	\title{An empirical evaluation of state channels as a scaling solution for cryptocurrencies}
	\maketitle
	\begin{abstract}
		So-called Layer 2 and Off-chain solutions are heralded as a scaling solution for cryptocurrencies. 
	\end{abstract} 

\section{Introduction}

We propose a new state channel construction that combines the dispute process model from Sprites to support $n$-parties, the ability to turn a channel on/off by requiring the dispute process to determine the latest state commitment from L4/PERUN and finally it incorporates state commitments from PISA such that the dispute process is only responsible for accepting the latest state commitment that was authorised by all parties. 


\begin{itemize}
\item A new dispute process that supports any application and ensures quick liveness of the application (i.e. sprites, every command dispute = slow, L4/Perun requires incorporating channel into app)
\item Financial incentives + fraud proofs can be used to avoid elaborate cryptography to build meaningful applications. Can only go so far (i.e. makes sense for battleships as everything is eventually revealed, but not e-voting) 
\item The first empirical evaluation of state channels as a scaling solution. 

\end{itemize}
\section{Background}

\subsection{Ethereum and smart contracts}


A smart contract is a state machine, where the state transition is executed on-chain based on an authorised command. 


\subsection{Evolution of channel constructions}

In Bitcoin - dispute process is to determine latest state and "close" the channel. Awkward to make this work - Lightning relies on revocation/penalty to enforce latest state is broadcast/accepted. 

In Perun/L4 - the dispute process is to determine the latest state and "close" the channel. 

In Sprites - dispute process is to process "commands" such as payments / withdrawals. Useful for single-purpose commands, not great for continuous applications (i.e. gaming) due to dispute process per command.

In Pisa - dispute process extends Sprites, but adds privacy-preserving feature - this allows state channel contract to be independent of the application. 

\section{State Channel Construction} 

%We propose a state channel contract and modifications to an application contract that is required to support the state channel.
We propose a new state channel contract $\statechannel$ and a template of modiciations for an application contract $\appcontract$  to support state channels. 
This modification provides a mechanism for locking (and unlocking) the application into a state channel upon approval of all parties. 

At a high level, the locking mechanism $\applock$ disables all functionality within the application contract and instantiates the state channel contract. 
Once locked, all parties execute the application off-chain amongst themselves by proposing  and co-operatively signing the hash of every new state alongside an incremented counter. 
A state hash is only considered valid when each party has received a signature from every other party. 
To turn off the channel, any party can trigger the dispute process using $\statechanneldispute$ via the state channel contract.
This provides  a fixed time period  for all parties to publish the state hash with the largest monotonic counter using $\statechannelsetstate$. 
After the dispute process has expired, any party can resolve the dispute using $\statechannelresolve$ which turns off the channel, confirms the state hash with the largest monotonic counter as the accepted state, and allows any party to unlock the application contract $\appunlock$. 
To unlock, any party can reveal the state (in plain text) to the application contract and this opening is verified by fetching the final state hash from the state channel contract using  $\statechannelgetcommitment$. 
Once verified, the full state is stored within the application contract and all functionality is re-enabled to permit execution to continue on-chain. 

In the following, we present the new state channel contract and the modifications required to an application contract. 


\subsection{State channel contract}

%\paddy{I'd like to add "commands" into the state channel; so we can add/remove new participants (or withdraw coins) without turning off the channel. Basic SPRITES construction! }

%The state channel contract manages the dispute process and it is responsible for determining the state commitment that is used by the application contract before its functionality is re-enabled to permit on-chain state transitions. 
We provide an overview of the state channel construction before discussing how to set it up, how participants authorise state transitions off-chain and how the dispute process confirms the final state hash. 

\paragraph{Overview of the state channel contract} 
Figure \ref{fig:statechannel} presents an overview of the state channel contract. 
It contains a list of parties $\participant_{1},...,\participant_{n}$, a dispute timer $\timerdispute$, the application contract's address $\appcontract$ and a  $\chanstatus = \{\chanon, \chandispute, \chanoff\}.$

Upon creation, the contract is set as $\chanstatus := \chanon$ and all parties can collectively execute the application by signing every new state hash (and an incremented nonce).
This is denoted as $\sigma_{\participant} := \sign_{\participant}(\hstatei, \monotoniccounter)$, where  $\hstatei = \hash(\stateinfoi, \rani)$ is the state hash ($\ran$ is a nonce) and $\monotoniccounter$ is an incremented monotonic counter. 
A state hash is only considered valid when each party has a signature from every other party. 
If one party aborts and does not sign the state hash, then any party can turn off the channel by triggering a dispute using $\statechanneldispute$ which sets $\chanstatus := \chandispute$. 

This provides a fixed time period between $\timenow$ and $\timedispute$ for all parties to respond using $\statechannelsetstate$ with $\hstate$, its monotonic counter $\monotoniccounter$ and a corresponding signature from every party $\Sigma_{\participant}$. 
Afterwards, any party can resolve the dispute using $\statechannelresolve$ which sets $\chanstatus := \chanoff$ and allows the final $\hstatei$ to be fetched by $\appcontract$ using  $\statechannelgetcommitment$. 
Finally the dispute time period and the final counter is recorded which can later be fetched using $\statechannelgetdispute$. 
%
%
%This command alongside a commitment to the new state and 
%This command alongside a signed state commitment tuple $(\hstateplus,\monotoniccounter+1)$ is sent to the other parties.
%To verify, each party computes the new $\stateinfoplus$ (and its corresponding counter) using the received $\cmd$ before exchanging their signature for the new state commitment. 
%A state commitment is not considered authorised until every party has a signature from every other party in the channel. 
%If one party aborts and does not sign the state commitment, then any party can trigger the dispute process in the state channel. 
%This provides a fixed time period for all parties to submit the latest authorised commitment $h_{i+1}$ alongside a list of signatures $\sigma_{p1},...,\sigma_{pn}$ to the state channel contract.
%Once the dispute process has expired, the commitment $h_{n}$ with the largest monotonic counter is considered the final state and it becomes available for the application contract to fetch. 

\paragraph{Creating the channel} 

The application contract $\appcontract$ is responsible for instantiating the state channel contract and providing it with the list of participants $\participant_{1},...,\participant_{n}$, the dispute timer $\timerdispute$, the address $\appcontract$ and setting $\chanstatus := \chanon$. 
As we discuss in the next section, all functionality in the application contract is disabled after the state channel contract is created. 

\paragraph{Authorising off-chain state hashes}
A command $\cmd$ is a function call within the application contract.
Any party can select a command $\cmd$ and propose a new state transition $\stateinfoplus := \mathsf{transition}(\stateinfoi, \cmd)$.
The new state is hashed  $\hstateplus = \hash(\stateinfoplus, \ranplus)$ and signed  $\sigma_{\participant} := \sign(\hstateplus,\monotoniccounter+1)$.
To finalise the state transition, the proposer sends $\cmd,\hstateplus, \stateinfoplus, \ranplus$ to all other parties for their approval.

All other parties in the channel verify the state transition before authorising it. 
To verify, each party re-computes the state transition $\stateinfoplus' := \mathsf{transition}(\stateinfoi, \cmd)$ and the state hash $\hstateplus' := \hash(\stateinfoplus', \ranplus)$.
Then, each party verifies the received signature $\verifysig(\participant, (\hstateplus', \monotoniccounter+1), \sigma_{\participant})$ and that the counter is the largest received so far. 
If satisfied, each party signs the state hash  $\sigma_{k} := \sign(\hstateplus,\monotoniccounter+1, \statechannel, \appcontract)$ and sends their signature alongside the state information $\cmd,\hstateplus, \stateinfoplus, \ranplus, \sigma_{k}$ to all other parties. 

The new state hash is only considered valid when each party has received a signature from every other party.  If one party does not receive all signatures within a local time-out, then this party can trigger the dispute process to turn off the channel and continue the application's execution on-chain. 

\paragraph{Dispute process.} 

Any party can trigger the dispute process using $\statechanneldispute$ which self-enforces a time period $\timestart := \timenow$, $\timeend := \timedispute$ and sets $\chanstatus = \chandispute$. 
Any party can submit the latest state hash (alongside a signature from every party $\Sigma_{\participant})$ during the dispute period using $\statechannelsetstate$. 
The state channel contract $\statechannel$ only stores the $\hstatei$ if it is  signed by all parties within the state channel and it is  associated with the largest $\monotoniccounter$ received so far. 
After the dispute period has expired, any party can resolve it using $\statechannelresolve$ which sets $\chanstatus = \chanoff$, stores a dispute record ($\timestart,\timeend, \monotoniccounter$) and allows the application contract $\appcontract$ to fetch the final state hash $\hstatei$. 

\subsection{Application Contract}

We propose a state channel template to modify an application contract. 
The template disables all functionality in $\appcontract$  after instantiating the state channel and re-enables the application to support continuous on-chain execution after turning off the state channel. 
In the following, we provide an overview of the template before discussing the locking and unlocking mechanism. 


\paragraph{Overview of template. } \label{sec:template} 
Figure \ref{fig:appmodify} presents an overview of the application contract template.
After modifications, the application contract must explicitly record a list of participants $\participant_{1},...,\participant_{n}$, a dispute timer $\timerdispute$, whether the state channel has been instantiated  $\instantiated := \{\instantiatedyes, \instantiatedno\}$ and if so it also stores the state channel's address  $\statechannel$. 
All functions within the application require a new pre-condition to check whether the state channel is instantiated and should only permit execution if $\instantiated = \instantiatedno$. 
Finally the application must include two new functions $\applock$ that instantiates the state channel upon approval of all parties and $\appunlock$ that verifies a copy of the full state before re-enabling the application. 


%A dispute time period 
%An explicit list of participants 
%A new boolean (on/off) and a pre-condition for every function in the contract (i.e. only allow function to be used if state channel is off)
%Two new functions: create channel (requires a signature from all parties) and setstate (receive full state, fetch hash, compare, store on-chain and re-enable functionality). 


 
\paragraph{Lock application contract} All parties must approve to instantiating the state channel by signing $(\chanon, \appcontract, \timerdispute, \mathsf{k}$), where $\chanon$ signals turning on the channel, $\mathsf{k}$ is an incremented counter to ensure freshness of the signed message and $\timerdispute$ is the fixed time period for the dispute process. 
Any party can call $\applock$ with the list of signatures $\Sigma_{\participant}$, $\timerdispute$ and $\mathsf{k}$ to turn on the state channel. 
The application contract $\appcontract$ verifies all signatures and that $\mathsf{k}$ represents the largest counter received so far.
If satisfied, $\appcontract$ sets  $\instantiated := \instantiatedyes$ effectively disables all functionality within the application.
Next $\appcontract$ creates the state channel contract $\statechannel$ which sets the list of participants $\participant_{1},...,\participant_{n}$ and the dispute timer $\timerdispute$. 
Finally $\appcontract$ stores the state channel address $\statechannel$. 
 

\paragraph{Unlock application contract}

After the dispute process has concluded in $\statechannel$, one party must send  $\stateinfoi',\rani'$ using $\appunlock$ before the functionality can be re-enabled.
The application contract verifies that $\stateinfoi'$  indeed represents the final state by computing $\hstatei' := \hash(\stateinfoi', \rani')$, fetching the final state hash $\hstatei$ from $\statechannel$ using $\statechannelgetcommitment$ and checking  $\hstatei' = \hstatei$. 
If satisfied, $\appcontract$ stores $\stateinfoi'$ and re-enables all functionality by setting $\instantiated :=  \instantiatedno$. 
Of course, if there is no activity within the state channel, then the state channel contract's dispute process can expiry without a submitted $\hstatei$.
In this case, the application contract verifies the state channel returns $\emptyset$ and re-enables all functionality without modifying the existing state. 


%Notes: While all functionality is disabled on-chain; we need to be careful with how parties execute it off-chain! Not all functionality can be supported off-chain (i.e. contract to contract interaction); so this needs to be considered. 

\section{Battleship within a State Channel} 

%In this section, we propose tow contracts for the game battleship and demonstrate how it can be adopted to support state channels. 
%One battleship game relies on a commitment to every slot in the grid and every ships, while the other battleship game simply has a commitment to every ship. 
%We highlight that our game relies on financial incentives and fraud proofs to self-enforce its integrity as opposed to extensive cryptography.
We provide a high-level overview of the battleship game before proposing two smart contracts. 
The first contract requires a commitment to every slot in a player's board alongside a list of ship commitments, whereas the second game only relies on a list of ship commitments. 
Afterwards we discuss how to overcome the computational limitation of checking a full board's validity by relying on a challenge-response protocol (i.e. a dispute process).
This provides a fixed time period for a player to submit a proof of fraud that the counterparty's board is invalid and if the proof is correct then the contract atomically forfeits the counterparty's deposit. 
Finally we present how to convert both contracts to support state channels using the template in Section \ref{sec:template}. 
%We propose two contracts for the battleship game where one game has a commitment to every slot in the grid $\hslot_{i,j}$ and every ship $\hship_{1},...,\hship_{n}$, where the second game simply has the list of ship commitments. 
%Afterwards, we present the fraud proofs which are compatible with both contracts and how to convert them to support state channels. 

\subsection{Overview of Battleship Contracts}

Battleship is a two-player game where each player has a list of ships and a 10x10 private board. 
Each ship must be marked in a straight line either horizontally or vertically, and ships cannot be placed adjacent to each other.\footnote{Ships must be surrounded by water if there is available space on the board.}.

To set up the game, both parties participate in a cut-and-choose protocol.
Each player commits to a list of $N$ boards (or $N$ lists of ships) using $\battleshipcommit$. 
The counterparty selects one board (or list of ships) for the player using $\battleshipselectboard$.
Once selected, each player reveals the remaining $N-1$ boards (or list of ships) to the counterparty. 
If both parties are satisified that all revealed boards are well-formed, they can signal to begin the game using $\battleshipbegin$, otherwise they may chose to quit using $\battleshipgameover$. 

%In the first contract, each player commits to $N$ boards using $\battleshipcommit$, whereas in the second contract each player simply commits to $N$ lists of ships. 
%Next, the counterparty selects a single board (or a single list of ships) using $\battleshipselectboard$. 
%Then, each player reveals all non-selected boards and list of ships to counterparty and this provides them an opportunity to verify all boards (and list of ships) are well-formed. 
%If each player is satisified, then they signal their desire to begin the game using $\battleshipbegin$ 
%Once the game is set up, both players take turns at shooting the other player's board.
In each turn, the player selects a slot to shoot using $\battleshipattackslot$ and the counterparty must open the slot  within a fixed challenge time period. 
To open, the counterparty reveal if the slot is occupied by water or a ship location using $\battleshiprevealslot$ which also indicates if it was a successful shot. 
If the player also sinks a shop, then the counterparty must reveal the full ship (alongside the slot's opening) using $\battleshipsinking$. 
The slot's opening (and if a ship was sunk) is recorded in the contract. 
Of course, the player is provided another turn if their shot was successful.
Throughout the game, the loser may have an opportunity submit a proof of fraud using $\battleshipfraud$ if it is detectable the counterparty's board (or list of ships) is invalid. 

At the end, the winner must reveal their board and every ship's location to the loser using $\battleshiprevealboard$.
The loser has a fixed time period to prove if the winner's board was incorrectly set up using $\battleshipfraud$, otherwise either player calls $\battleshipgameover$ to finish the game. 


\subsection{Battleship Game (with Board)} 

In the following, we discuss in-detail how to set up the game, the turn-based mechanisms for shooting/revealing a slot on the board and  how to finish the game. 


\paragraph{Game Phases} There are six phases $\{\gameregister, \gamesetup, \gameattack, \gamereveal,  \gamewinner, \\ \gamefinished\}$. 
The $\gameregister$ phase initialises the contract with an initial deposit from both players and the challenge timer $\timerchallenge$.
The $\gamesetup$ phase is responsibe for selecting a single board (and a list of ships) for each player before the game begins.
Game play involves several transitions between $\gameattack$ and $\gamereveal$ as both players take turns at shooting the counterparty's ships. 
When one player wins the game, the game transitions to $\gamewinner$.
This requires the winner to reveal their board and the corresponding list of ships. 
The loser is provided with a fixed time period to submit a proof of fraud that the winner's board is not well-formed, otherwise the contract transitions to $\gamefinished$. 

\paragraph{Representing the board and ships} 
%All slot and ship locations include a unique nonce $r$. 
A board is a 10x10 grid and each slot is represented as $\hslot_{i,j} := \hash(b, r)$, where $i,j$ is the slot position, $b$ indicates if it is marked as a ship location.
Each ship is the tuple $(k,\hship)$, where $k$ is the ship's length and $\hship := \hash(i,j,...,i',j',r)$.
Each player has a list of ships $(k,\hship),...,(k',\hship')$ and the full board is represented:

\begin{center}
$\hboard := \hash(\hslot_{0,0},...,\hslot_{10,10},(k_{1},\hship_{1}),..,(k_{n},\hship_{n}), \mathsf{round}, \participant, \appcontract)$
\end{center}

%Where the game $\mathsf{round}$ is a monotonic counter and $\participant$ is this party's address. 

\paragraph{Game setup and registration} 
There is a time for dispute $\timedispute$, a deposit from both parties and coins are allocated for any new game. 

\paragraph{Prepare battleship board} Both parties participate in a cut-and-choose protocol during $\gamestatus := \gamesetup$. 
Each party computes and sends the counterparty $N$ boards.
The counterparty selects one $\hboard$  and reserves it for the game using $\battleshipselectboard$. 
After selecting a board, the party must reveal all other $N-1$ boards to the counterparty. 
If satisified, each party notifies the contract to begin the game and reveals the opening of $\hboard$ which is every slot commitment $\hslot_{0,0},..,\hslot_{10,10}$ and ship commitment $(k_{1},\hship_{1},...,k_{n},\hship_{n})$ using $\battleshipbegin$.
The contract verifies the opening of $\hboard$ before storing the entire board and accepting this notifcation to begin the game.
This acts as an explicit acknowledgement the party has reviewed all revealed boards from the counterparty.
If the counter-party does not reveal any boards (or if the boards are invalid), then the party can signal their desire to quit  using $\battleshipgameover$.\footnote{The counter-party can be forced to reveal every board on-chain to test its validity and potentially forfeit their deposit, but this is prohibitively expensive for $N-1$ boards.}
Finally the game $\mathsf{round}$ is incremented regardless if it continues or not. 

\paragraph{Game-play} \label{sec:gameplay}
The game phase transitions several times between $\gameattack$ and $\gamereveal$ as each player has a turn at shooting the counterparty's board. 

In the $\gameattack$ phase, the player challenges the counterparty to reveal a slot $i,j$ using $\battleshipattackslot$.
This transitions the game phase to $\gamereveal$ and sets a fixed time period $\timechallenge := \timenow + \timerchallenge$ for the counterparty to respond with an opening of $\hslot_{i,j}$ alongside whether this shot has sank a ship.
If this shooting has not sank a ship, then the counter-party responds using $\battleshiprevealslot$ with $(b,r)$ to reveal $\hslot_{i,j}$. 

On the other hand if this shot has sank a ship, then the counter-party responds using $\battleshipsinking$ with $(b,r)$ to reveal $\hslot_{i,j}$ and $(i,j),...,(i',j'),r$ to reveal the sank $\hship$. 

The game transitions to $\gamefraud$ if the maximum number of possible moves has been exceeded or it transitions to $\gamewinner$ if one player has declared all their ships sunk. 

\paragraph{Fraud phase} 

If the game transitions to $\gamefraud$, then the party who fraud was proven loses their deposit. 
The counterparty must reveal their full board and a fixed time period $\timerchallenge$ is enforced to permit time for the party to submit a proof of fraud using $\battleshipfraud$. 
Again, if fraud is proven then both parties forfeit their deposit, otherwise the loser wins and the game transitions to $\gamefinished$ 

\paragraph{End of game} 

The winner reveals their full board and corresponding ships using $\battleshiprevealboard$.
A fixed time period is enforced to permit time for the loser to submit a proof of fraud using $\battleshipfraud$.
After this time period, the winner can redeem their reward using $\battleshipgameover$ which also transitions the game phase to $\gamefinished$. 

\subsection{Battleship game (without board)}

\paragraph{Prepare battleship board}. 
There is no board, but every player commits to a list of ships. 

\paragraph{Game-play} 
Challenge to reveal slot, counterpaty submits a signed message for the revealed slot (which is stored via an event). 
Game play is as normal. 

\paragraph{End of game} 
Winner must reveal all ship commitments. Loser has opportunity to prove fraud using signed messages. 

%,(i,j)$  
%the signed message $\sign_{\participant}((b, r), (i, j), \instantiatedno, \appcontract)$.

%$\sign_{\participant}((b, r), (i, j), \instantiatedyes, $ $(r_{1},...,r_{k}), \appcontract)$, where $r_{1},...,r_{k}$ are the nonces required to open $\hshiplocation_{1},...,$ $\hshiplocation_{k}$. 

\subsection{Proof of Fraud}

The game relies on each player submitting a proof of fraud using $\battleshipfraud$ if an invalid board (or list of ships) is publicly detected.
This is necessary as validating the board (and the list of ships) is a computationally expensive searching problem.\footnote{TODO: Can we get some evidence? or at least some intuition how long it takes? https://stackoverflow.com/questions/7501344/how-to-validate-battleship-field }  
In the following, we highlight all committed data must be well-formed in order to win the game and thus we present four fraud proofs which focus on the revealed data's integrity. 

% our fraud proofs focus on the integrity of the committed data.  the committed data must be correctly formatted in order to win the game before presenting four fraud proofs which will convince $\appcontract$ that can be submitted to the contract which demonstrate that the revealed board or its corresponding list of ships are not well-formed. 

\paragraph{Pre-images for slots or ship locations are not formatted correctly} 
The contract cannot process the slots or ship locations using $\battleshiprevealboard$ if the pre-image of any hashes are not correctly formatted and thus the cheating player can never win the game.
As a result, our fraud proofs focus on information stored within a correctly formatted pre-image of a hash and proves if the game logic was violated.
For example, the list of positions within a $\hshiplocation$ must correspond to a marked location on the board. 

\paragraph{Ships not placed on the board}
This proof assumes the full board and the ship locations are revealed. 
The contract can verify whether the ship location $i,j$ of $\hshiplocation$ was indeed marked on the board at $\hslot_{i,j}$. 

\paragraph{Adjacent ships} 
We denote $i,j$ as the location for the first $\hshiplocation$ and $i',j'$ as the location for the second  $\hshiplocation'$. 
The contract can verify if ships are adjacent by checking whether $i,j$ is within the range $i'\pm1, j'\pm1$ or if they claim to be at the same location $i,j = i',j'$.

\paragraph{Ships not placed horizontally or vertically} 
The contract is provided with all pre-images for the entire ship $\hshiplocation_{1}, ..., \hshiplocation_{k}$.
To verify a ship is straight, the contract verifies if every location has the same $i$ or $j$ co-ordinate. 
To verify a ship is a line, one of the co-ordinates $i$ or $j$ must increment (or decrement) strictly by one for every ship location. 

\paragraph{Ship was not declared as sunk}
The player can prove the counterparty did not declare a ship as sunk (and in effect they have wasted  the player's next turn).  
As we mentioned in Section \ref{fig:statechannel}, the counterparty must calls $\battleshipsinking$ if to indicate the revealed slot on the board has indeed sank a ship and the contract is required to maintain a record of the sinking. 
To prove fraud, the player provides $\battleshipnotsunk$ with the revealed ship $\hshiplocation$ and the adjacent (and revealed) water slots. 
The contract can verify the adjcaent water slots are indeed before and after the ship, and that none of the ship locations were marked as sinking the ship. 

%At the time of reveal, the counterparty must also specift whether this shot has sunk the ship which updates the slot as  sinking tile. 

% $\hslot$  in the contract is marked as hit if a ship was hit, but not declared as sunk, then the contract the counterparty signs a reveal message 
%$\sign_{\participant}(b, r, i, j, \instantiatedno, \appcontract)$.


%Assuming all signed messages are stored by the non-cheating player, then there are two cases when they can be used.
%In the first case, the player can finish the game early if their shots reveals two slots which are marked as water before and after a ship which has not been declared as sunk.
%The player can provide $\battleshipnotsunk$ with the list of signed reveal messages from the counterparty which indicates the ship was not sunk and the two additional slots marked as water. 
%The contract can simply verify the two slots are indeed before and after the ship, and that the counterparty did not declare their ship as sunk after all successful shots.
%In the second case, the additional two slots are not required when $\gamestatus := \gamewinner$ as the full board (and list of ships) are revealed. 
%The player can simply provide the list of signed reveal messages from the counterparty and identify which ship was sunk. 
%The contract can verify the counterparty did not declare the ship as sunk, but the ship was indeed fully hit. 

%partially revealed board demonstrates 
%Crucially, this fraud proof is also valid in $\gamestatus := \gamewinner$ after the winner's board is revealed. 

%Attack: In reality, after hitting a bit of the ship - it could have sunk. The counterparty can lie and say the ship was not sunk - just to waste players move. 
%Fraud proof: Player can send all signed messages (i.e. bit reveals) - and if none of the messages %say "SUNK" (along all bits were hit!) - then it is evidence the counterparty cheated. This becomes obvious after the player has wasted 1-2 moves (i.e. hit A1,A2,A3,A4, but A1 and A3 are water!) 


\subsection{Modifying battleships to support state channels}

\paragraph{Modify all functions to be disabled if state channel is created}

\paragraph{Continue application execution on-chain if counterparty aborts}
There is no incentive for the counterparty to authorise a state where their fraud has been prove, or if they are about to lose coins. The party can always submit the last authorised state to "turn off" the channel, and then continue the execution on-chain. But this highlights issues with timers - how do we create them such that they "only" start ticking after the dispute process is turned off? Does this require an explicit modification to how the timers are set up? Or do we just take the dispute process "into account". 

\section{Experiment on Ethereum's Test Network}

\section{Discussion} 

\paragraph{Channel vs Plasma} Validators = users, whereas validators != users. Both rely on a global blockchain as a root of trust. 

\paragraph{Private blockchain} All participants can execute a smart contract via a private blockchain (to simulate its execution), and sign the resulting state amongst themselves. After all, we only care for the normal execution of a smart contract. 

\paragraph{Dynamic Participation} Unlike Sprites/PISA, new parties cannot be added to this state channel. All parties would have to close/re-open the state channel. Although it is feasible to "combine" both constructions to support commands for adding parties to the channel, and then for the latest state. We leave this as future work for now. 

\paragraph{Go through top 100 contracts by volume, make sense in a channel?} 
\paragraph{Non-attributable problem} Fundamentally, it appears impossible to determine the cause behind a dispute on the blockchain. i.e. one party refuses to sign update; or A just doesnt send B's signature to blokchain and instead sends a previous state.

\paragraph{Funfair Dilemma} Should we optimise for minimal on-chain or off-chain state? Sprites/PISA/Funfair assume everything is on-chain (via single application) and Perun/L4 assume several contracts can live off-chain. 

This also raises the problem of splitting transaction fees. In a 2 party channel it is straight-forward (i.e. split half way), but in a n-party channel - the griefer can cause a multiplier of fee cost to everyone. Even worst as mentioned before - no evidence who the griefer is! 

\paragraph{Chicke and egg problem} Does the app contract create state channel? Or should the state channel create the application? Related to funfair dilemma - one assumes contract is already on-chain, other assumes it is created off-chain. 


\paragraph{Applications of state channels} All parties must remain on-line for the execution of a state channel. As a result, applications may be context-specific (i.e. quick auctions for buying/selling AdWords, but not for the Ethereum Name Service). 

\paragraph{Application Timers} There is support for both absolute and relative timers. Relative timers are ideal as they allow the designer to avoid considering the dispute process time (i.e. it starts ticking once the application is re-activated). However, absolute time locks are sometimes necessary/unavoidable (i.e. HTLC transfers). 

\paragraph{Benefit to PISA} All applications rely on a single state channel contract. Thus, a custodian only has to verify the bytecode for a single contract and can accept jobs for any application. 

\paragraph{Race conditions} What if two commands are proposed at the same time? No way to resolve that. Same problem with front-running and contracts. issues do not go away. Not problem for battle-ship, as the game dynamics are clearly defined as a force-move game. 

\paragraph{Limitations due to EVM/Solidity} Cannot delete a mapping - problems if channel is created half-way thru and app; and you update values in the mapping! need to keep an array of all key-values... could try to store all state in a single contract, delete/recreate contract; but that is expensive (similar to the dispute registry).  

\paragraph{Probablistic checking board's integrity} Impacts the UX/fun of the game. i.e. you need to have a randomly allocated board, ruins the fun. Could have a zkSNARK to prove integrity of the board. In fact, due to the commit, reveal and then explicit acknowledgement to begin the game - the game does not need to verify the zkSNARK (or any of the N boards validity). We leave this as future work.  

\paragraph{Attacks we cant solve} Griefing - every time we ask counterparty to reveal commitment - there has to be a fixed time period to do it - similar to real life - there is nothing we can do about it - and due to latency on the network - the game could be dragged out for hours. This provides a benefit to use something like Plasma - where the block latency can be super quick (and thus the counterparty has 5 minutes to reply, and not 1 hour). State channel cant get around this -by definition we always hit the worst case. 
 
\appendix

\section{Security Analysis for Battleship Game}


\begin{figure}[h]
	\begin{boxedminipage}{\columnwidth}
		\begin{center}
			\textsf{State channel contract}{}\\
		\end{center}
		
		$\chanstatus := \bot \\
		\participant  := \emptyset, \appcontract := \bot, \\ \hstate := \bot, \monotoniccounter := 0 \\ \timerdispute := 0, \timenow := 0, \timeend := 0$
		
		\begin{flushleft}
			\constructor($\participant', \timerdispute', \appcontract'$):
			
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{set} $\participant := \participant'$ \\
			\quad \textbf{set} $\timerdispute := \timerdispute'$ \\ 
			\quad \textbf{set} $\appcontract := \appcontract'$ \\
			\quad \textbf{set} $\chanstatus := \chanon$ \\
			
		\end{tabular}
		
		\begin{flushleft}
			\oninput \stringlitt{triggerdispute}($\sigma_{k}$): 
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\chanstatus \neq \chanon$ \\
			\quad \textbf{discard if} $\participant \notin \participant_{k}$ \\
			\quad \textbf{if} $\verifysig(\participant_{k}, (\statechannel, \appcontract, ``\mathsf{dispute}"), \sigma_{k})$ \\
			\quad \quad \textbf{set} $\chanstatus := \chandispute$ \\
			\quad \quad \textbf{set} $\timestart := \timenow$ \\
			\quad \quad \textbf{set} $\timedispute := \timestart + \timerdispute$
			
		\end{tabular}
		
		
		\begin{flushleft}
			\oninput  \stringlitt{setstatehash}($\hstate', \monotoniccounter', \Sigma_{\participant}$):
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\chanstatus = \chanoff$ \\
			\quad \textbf{discard if} $\monotoniccounter' \leq \monotoniccounter$ \\
			\quad \textbf{if} $\verifysig(\participant, (\hstate', \monotoniccounter', \statechannel, \appcontract), \Sigma_{\participant})$ \\
			\quad \quad \textbf{set} $\hstate := \hstate'$ \\
			\quad \quad \textbf{set} $\monotoniccounter := \monotoniccounter'$ \\
		\end{tabular}
		
		\begin{flushleft} 
			\oninput \stringlitt{resolve}(): 
		\end{flushleft}
		\begin{tabular}{l}
		\quad \textbf{discard if} $\chanstatus \neq \chandispute$ \\
		\quad \textbf{discard if} $\timenow < \timeend$ \\
		\quad \textbf{set} $\chanstatus := \chanoff$ 
		\end{tabular}
	
		\begin{flushleft} 
		\oninput \stringlitt{getstatehash}(): 
		\end{flushleft}
		\begin{tabular}{l}
		\quad \textbf{discard if} $\chanstatus \neq \chanoff$ \\
		\quad \textbf{return} $\hstatei$
		\end{tabular}
		
		\begin{flushleft} 
			\oninput \stringlitt{getdispute}(): 
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\chanstatus \neq \chanoff$ \\
			\quad \textbf{return} $(\timenow, \timeend, \monotoniccounter)$
		\end{tabular}
	\end{boxedminipage}
	\caption{The state channel contract. It is responsible for managing the dispute process and determining the final state hash.  Discard fails the transaction execution if the pre-condition is satisfied.} \label{fig:statechannel}
\end{figure}

\begin{figure}
\begin{boxedminipage}{\columnwidth}
	\begin{center}
		\textsf{Template for application contract}{}\\
	\end{center}
	
	$\instantiated := \bot,  \stateinfo := \bot \\ 
	\participant  := \emptyset,  \timerdispute := 0, \\
	\statechannel := \bot, \mathsf{k} := 0$
	
		
	\begin{flushleft}
		\constructor($\participant'$): 
	\end{flushleft}
	\begin{tabular}{l}
		\quad \textbf{set} $\participant := \participant'$ \\
		\quad \textbf{set} $\instantiated := \instantiatedno$ \\
		
	\end{tabular}

	\begin{flushleft}
		\oninput \stringlitt{example}(): 
	\end{flushleft}
	\begin{tabular}{l}
		\quad \textbf{discard if} $\instantiated \neq \instantiatedyes$ \\
		\quad \_;
		
	\end{tabular}
	
	
	\begin{flushleft}
		\oninput  \stringlitt{lock}($\timerdispute', \Sigma_{\participant}$):
	\end{flushleft}
	\begin{tabular}{l}
		\quad \textbf{discard if} $\instantiated = \instantiatedyes$ \\
		\quad \textbf{if} $\verifysig(\participant,(``\mathsf{instantiate}", \appcontract, \mathsf{k}),\Sigma_{\participant})$ \\
		\quad \quad \textbf{set} $\instantiated := \instantiatedyes$ \\
		\quad \quad \textbf{set} $\mathsf{k} := \mathsf{k} + 1$ \\
		\quad \quad \textbf{set} $\statechannel := \mathsf{StateChannel}(\participant, \timerdispute, \mathsf{this})$
	\end{tabular}
	
	\begin{flushleft} 
		\oninput \stringlitt{unlock}($\stateinfo',\ran'$): 
	\end{flushleft}
	\begin{tabular}{l}
		\quad \textbf{discard if} $\instantiated \neq \instantiatedyes$ \\
		\quad \textbf{if} $\hash(\stateinfo', \ran') = \statechannelgetcommitment()$ \\
		\quad \quad $\instantiated := \instantiatedno$ \\
		\quad \quad $\stateinfo := \stateinfo'$ \\
		\quad \textbf{else if} $\bot = \statechannelgetcommitment()$  \\
		\quad \quad $\instantiated := \instantiatedno$
	\end{tabular}
\end{boxedminipage}

	\caption{The application contract template. The above modifications must be included to support a state channel. It allows all functionality to be disabled when the channel is created and re-enables all functionality after the dispute process when provided with the full state.}\label{fig:appmodify}
\end{figure}

\end{document}
