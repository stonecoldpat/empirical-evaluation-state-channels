\PassOptionsToPackage{usenames}{xcolor}
\PassOptionsToPackage{dvipsnames}{xcolor}
\documentclass{llncs}
\usepackage[utf8]{inputenc}
\usepackage{booktabs} % For formal tables
\usepackage{multirow}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{url}
\usepackage{xspace}
\usepackage{pifont}% http://ctan.org/pkg/pifont
\usepackage{color}
\usepackage{boxedminipage}
\usepackage[ff,sets,keys,primitives,operators]{cryptocode}
\usepackage{framed}
\usepackage[group-separator={,}]{siunitx}
\newcommand\bmmax{2}
\usepackage{bm}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{footnote}
\usepackage{units}
\usepackage{multicol,lipsum}
\colorlet{iomsg}{MidnightBlue}
\colorlet{party}{brown}
\colorlet{entry}{NavyBlue}
\colorlet{string}{BlueViolet}

\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%

\newcommand{\instantiated}{\mathsf{instantiated}}
\newcommand{\instantiatedno}{\mathsf{NO}}
\newcommand{\instantiatedyes}{\mathsf{YES}}

\newcommand{\gamestatus}{\mathsf{phase}}
\newcommand{\gameregister}{\mathsf{INIT}}
\newcommand{\gamesetup}{\mathsf{SETUP}}
\newcommand{\gameattack}{\mathsf{ATTACK}}
\newcommand{\gamereveal}{\mathsf{REVEAL}}
\newcommand{\gamewinner}{\mathsf{WIN}}
\newcommand{\gamefraud}{\mathsf{FRAUD}}
\newcommand{\gamefinished}{\mathsf{GAMEOVER}}

\newcommand{\chanstatus}{\mathsf{status}}

\newcommand{\chanon}{\mathsf{ON}}
\newcommand{\chandispute}{\mathsf{DISPUTE}}
\newcommand{\chanoff}{\mathsf{OFF}}

\newcommand{\hready}{\mathsf{hready}}
\newcommand{\hboard}{\mathsf{hboard}}
\newcommand{\hcell}{\mathsf{hcell}}
\newcommand{\hship}{\mathsf{hship}}
\newcommand{\hshiplocation}{\mathsf{hshiplocation}}

%\newcommand{\hash}{\textsf{H}}
\newcommand{\cmd}{\mathsf{cmd}}
\newcommand{\hstate}{\mathsf{hstate}}
\newcommand{\hstatei}{\mathsf{hstate}_{\monotoniccounter}}
\newcommand{\hstateplus}{\ensuremath{\mathsf{hstate}_{\monotoniccounter+1}}}
\newcommand{\hstateminus}{\ensuremath{\mathsf{hstate}_{\monotoniccounter-1}}}
\newcommand{\monotoniccounter}{\mathsf{i}}
\newcommand{\stateinfo}{\mathsf{state}}
\newcommand{\stateinfoi}{\mathsf{state}_{\mathsf{i}}}
\newcommand{\stateinfominus}{\mathsf{state}_{\mathsf{i-1}}}
\newcommand{\stateinfoplus}{\mathsf{state}_{\mathsf{i+1}}}
\newcommand{\participant}{\mathcal{P}}

\newcommand{\rani}{\mathsf{r}_{\mathsf{i}}}
\newcommand{\ran}{\mathsf{r}}
\newcommand{\ranminus}{\mathsf{r}_{\mathsf{i-1}}}
\newcommand{\ranplus}{\mathsf{r}_{\mathsf{i+1}}}

\newcommand{\statechannel}{\mathsf{SC}}
\newcommand{\statechanneldispute}{\mathsf{SC}.\mathsf{trigger}}
\newcommand{\statechannelsetstate}{\mathsf{SC}.\mathsf{setstatehash}}
\newcommand{\statechannelresolve}{\mathsf{SC}.\mathsf{resolve}} 
\newcommand{\statechannelgetcommitment}{\mathsf{SC}.\mathsf{getstatehash}} 
\newcommand{\statechannelgetdispute}{\mathsf{SC}.\mathsf{getdispute}} 
\newcommand{\statechannelclose}{\mathsf{SC}.\mathsf{close}} 

\newcommand{\sign}{\mathsf{Sign}}
\newcommand{\verifysig}{\mathsf{VerifySig}}

\newcommand{\battleship}{\mathsf{BS}}
\newcommand{\battleshipfraud}{\mathsf{BS.fraud}}
\newcommand{\battleshipattackcell}{\mathsf{BS.attackcell}}
\newcommand{\battleshipbegin}{\mathsf{BS.begingame}}
\newcommand{\battleshipquit}{\mathsf{BS.quitgame}}
\newcommand{\battleshipcommit}{\mathsf{BS.commit}}
\newcommand{\battleshipplacebet}{\mathsf{BS.placebet}}
\newcommand{\battleshipselectboard}{\mathsf{BS.select}}
\newcommand{\battleshiprevealcell}{\mathsf{BS.opencell}}
\newcommand{\battleshipsinking}{\mathsf{BS.sunk}}
\newcommand{\battleshiprevealships}{\mathsf{BS.openships}}
\newcommand{\battleshiprevealboard}{\mathsf{BS.openships}}
\newcommand{\battleshipgameover}{\mathsf{BS.gameover}}
\newcommand{\battleshipdeposit}{\mathsf{BS.deposit}}
\newcommand{\battleshipwithdraw}{\mathsf{BS.withdraw}}
\newcommand{\battleshipfinish}{\mathsf{BS.finish}}

%\newcommand{\battleshipshipnotplaced}{\mathsf{BS.fraudnothit}}
\newcommand{\battleshipdeclarednotsunk}{\mathsf{BS.declarednotsunk}}
\newcommand{\battleshipdeclarednothit}{\mathsf{BS.declarednothit}}
\newcommand{\battleshipsamecell}{\mathsf{BS.attacksamecell}}
\newcommand{\battleshiptwoships}{\mathsf{BS.celltwoships}}
\newcommand{\battleshipchallengeexpired}{\mathsf{BS.expiredchallenge}}

\newcommand{\battleshiplock}{\mathsf{BS.lock}}
\newcommand{\battleshipunlock}{\mathsf{BS.unlock}}
\newcommand{\battleshipgetstate}{\mathsf{BS.getstate}}

\newcommand{\appcontract}{\mathsf{AC}}
\newcommand{\applock}{\mathsf{AC.lock}}
\newcommand{\appunlock}{\mathsf{AC.unlock}}

\newcommand{\timerchallenge}{\mathsf{\Delta}_{\mathsf{challenge}}}
\newcommand{\timechallenge}{\mathsf{t}_{\mathsf{challenge}}}
\newcommand{\timerextra}{\mathsf{\Delta}_{\mathsf{extra}}}
\newcommand{\timerdispute}{\mathsf{\Delta}_{\mathsf{dispute}}}
\newcommand{\timenow}{\mathsf{t}_{\mathsf{now}}}
\newcommand{\timestart}{\mathsf{t}_{\mathsf{start}}}
\newcommand{\timeend}{\mathsf{t}_{\mathsf{end}}}
\newcommand{\timedispute}{\timenow + \mathsf{\Delta}_{\mathsf{dispute}}}

% Colorful diagrams 
\newcommand{\constructor}{\textcolor{entry}{\bf constructor }}
\newcommand{\oninput}{\textcolor{entry}{\bf function }}
\newcommand{\stringlitt}[1]{\texttt{\textcolor{string}{#1}}}

\begin{document}

	\title{An empirical evaluation of state channels as a scaling solution for cryptocurrencies}
	\maketitle
	\begin{abstract}
%		Cryptocurrencies do not scale. The community are pursuing three scaling approaches which include new blockchain protocols, sharding and off-chain. 
%		New blockchain protocols can strictly increase the network's throughput and sharding can distribute the set of transactions verifired by peers on the network. 
%		However there is a tradeoff between increasing the throughput of transactions on the network and peers with the computational resources to validate every transaction. 
%		Off-chain protocols try to alleivate this tradeoff by reducing the transactions that must be validated by the network.
%		One leading off-chain approach is called a state channel which lets a group of parties to transact amongst themselves and only publish the final transaction. 
%		To evaluate state channels as a scaling solution, we explore the minimal modifications required for an application contract before it can be depoyed as a state channel. 
%		
%		 peers are resposible for verifying a set of transactions, there is a tradeoff between  are three scaling approaches tha
		So-called Layer 2 and Off-chain solutions are heralded as a scaling solution for cryptocurrencies. 
	\end{abstract} 

\section{Introduction}

Since 2009, we have witnessed the rise of cryptocurrencies as the market capitalisation for all cryptocurrencies peaked to \$1 trillion US dollars in December 2017.
While Bitcoin was the first cryptocurrency designed to support financial transactions, another promiment cryptocurrency called Ethereum has emerged for executing programs called smart contracts. 
The promise of smart contracts is to support the execution of applications without human oversight or a central operator. 
Some applications proposed include decentralised (and non-custodial) token exchanges, publicly verifiable gambling games, auctions for digital goods, boardroom electronic voting, etc. 

However cryptocurrencies do not yet scale. 
Bitcoin can support approximately 7 transactions per second and Ethereum can support around 13 transactions per second. 
The lack of scalability is one of the primary hurdles preventing global adoption of cryptocurrencies as the network's transaction fee typically become unaffordable  for most users whenever the transaction throughput ceiling is reached (i.e. the average fee in Bitcoin reached \$20 in December 2017).
The community are pursuing three approaches to scale the network which include new blockchain protocols, sharding the blockchain and off-chain protocols. 
New blockchain protocols such as DAGs can strictly increase the network's throughput, whereas sharding can be used to distribute transactions into processing areas such that peers only validate transactions that interest them. 
However there is a tradeoff between increasing the throughput and supporting a larger userbase in terms of affordable transaction fees, and the set of validators who have the computational resources to validate every transaction on the network.

An alternative scaling approach is called off-chain which aims to reduce the number of transactions processed by the blockchain.
It lets a group of parties to deposit coins into an off-chain application, transact amongst themselves without interacting with the global network, and finally re-distribute the deposited coins depending on the application's outcome. 
There are two proposals for the off-chain approach which includes an alternative blockchain (i.e. a sidechain) or a channel. 
A sidechain has a set of block producers (i.e. miners or a single operator) for deciding the order of transactions and users are responsible for signing/publishing transactions for inclusion. 
There are several sidechain protocols which bootstrap from Bitcoin (including a live network by RSK), whereas Plasma and NOCUST are non-custodial sidechains which bootstrap from Ethereum for financial transactions.
While sidechains are a promising off-chain solution, they still require a blockchain protocol which may also have a transaction throughput ceiling.
% and there is still no non-custodial sidechain protocol that can support executing smart contracts. 

On the other hand, a channel can be considered a non-fault tolerant (and $n$ out of $n$) consensus protocol.
All parties are collectively responsible for authorising every new state of the application amongst themselves.
There is no blockchain protocol and all parties typically only store the most recently authorised state of the application. 
Channels first emerged in Bitcoin to support one-way payments between two parties (i.e. a payment channel), but has since evolved in Bitcoin towards the development of an off-chain payment network by several companies including Blockstream, LND and ACINQ. 
% a sender can synchronise a single payment across a route of channels to the receiver. 
%Several companies including Blockstream, LND and ACINQ are implementing this off-chain payment network.
At the same time, there are several proposals by Sprites, Pisa, Perun and Counterfactual called state channels. 
All proposals  expand the capability of a channel to support a group of parties  to execute a smart contract amongst themselves as opposed to only faciliating payments. 
They promise to offer instant finality for every state update, no transaction fees, protection for each party against a full collusion of all other parties, and the throughput is only restricted by the network latency between the users. 
%when the group of parties have collectively authorised an application's new state, there are no transaction fees, the throughput is only restricted based on network latency between the users, and every user is protected against a full collusion of all other parties while they remain online. 
%While payment channels in Bitcoin are only required to guarantee the safety of deposited funds, a state channel must also guarantee liveness of the application such that an application's progress can be continued via the blockchain if a single party does not co-operate in the channel. 
To further explore state channels as a scaling solution, the Ethereum Foundation has donated over \$2.7m and the Ethereum Community Fund has donated \$275k to L4, Perun, Pisa, Enuma Technologies and Magmo. 
As well, several companies have raised substantial capital to build state channels including CelerNetwork with \$30m and FunFair \$20m.

In this paper, we present an empirical evaluation of state channels as a scaling solution for cryptocurrencies. 
To aid this evaluation we have designed a two-player battleship game as a smart contract.
We reduce the computational and storage overhead required by relying on the players validating the game play and providing a proof of fraud if cheating is detected.  
%Each player is responsible for validating the game and presenting a proof of fraud to the smart contract if there is cryptographic evidence of the counterparty cheating. 
This style of application is still not considered viable to execute via the blockchain due to the quantity of transactions required.
For example, each player may require up to 200 transactions (i.e. attack 100 cells and open 100 cells) per game and this will incur unreasonable transaction fees.
We chose battleship for our experiment as state channels are perceived as a potential scaling solution to allow similar applications to be executed over the blockchain. 
Our contributions are as follows: 

\begin{itemize}
\item We explore and present the minimal modifications required to deploy an application contract as a state channel, 
\item We present a new state channel construction which is application-agonostic, supports $n$ parties and allows the channel to be turned off such that the application's progress can continue via the blockchain. This combines the constructions from Sprites, Pisa, Perun and Counterfactual. 
\item We provide a proof of concept implementation to evaluate deploying applications within a state channel.
This experiment highlights the worst-case scenario of state channels and how it potentially renders applications like battleship as unreasonable to deploy within a state channel. 
\end{itemize}

\section{Background}

In this section, we provide background information about Ethereum, smart contracts and how the concept of a channel has evolved. 

\subsection{Ethereum and smart contracts}

All users are responsible for generating their own pseudonymous account $P$ which is simply a public-private key pair. 
If the account is associated with the network's native currency (i.e. ether), then the user can digitally sign transactions to send coins to other users or they can interact with global programs called smart contracts. 
All transactions are recorded and ordered in an append-only public ledger called the blockchain.
A group of financially invested users called miners are responsible for updating the blockchain with a new block of trasactions via a proof of work competition. 
If the block is accepted into the \textit{longest and heaviest blockchain}, then it is eventually considered the winner and in return the miner of this winning block is rewarded with newly minted coins. 
% Ethereum's blockchain protocol implements a variation of the GHOST protocol to partially reward blocks that were mined, but are not part of the longest and heaviest blockchain. 

Conceptually, a smart contract is a trusted third party with public state. 
It has a unique address on the network, it is instantiated based on the code supplied at the time of its creation, and all execution can be modelled as a state machine. 
Every transaction executes a command in the smart contract and which performs the following state transition $\stateinfoplus = \mathsf{transition}(\stateinfoi, \mathsf{cmd})$. 
It is considered a trusted third party as each peer which has verified the entire  blockchain has also replicated the program's entire execution. 
This mass-replication allows the network to enforce a smart contract's correct execution and this also implies that all data for the smart contract must be publicly accessible. 

\subsection{Evolution of channel constructions}

%A channel 
%After every state transition, each party should have a signature from every other party for the new state.
A channel is a non-fault tolerant consensus protocol (i.e. $n$ out of $n$) that allows a group of parties to execute a smart contract amongst themselves without interacting with the network. 
Each party must lock coins up in the underlying blockchain to set up the channel.
Next, the group of parties collectively execute state transitions and exchange signatures to authorise every new state of a smart contract. 
%The promise of a channel is that it allows parties to avoid transaction fees when executing a smart contract and also provide instant finality after all parties have exchanged signatures for a new state.  
If a single party does not co-operate and authorise a valid state transition, then the underlying blockchain becomes a root of trust to self-enforce it. 
As a result, the blockchain gurantees the safety of coins for all online parties and the smart contract's liveness such that the application will always progress. 
We present the evolution of channel constructions which first emerged in Bitcoin for financial transactions, but has since been taken further to support the execution of arbitrary applications in Ethereum.

\paragraph{Payment channels in Bitcoin} 
Spilman proposed relace by incentive which is the first state replacement technique and it is designed for one-way payments from a sender to receiver.
The sender submits a deposit to open  channel and this deposit can be redeemed if one of the following two conditions are satisified. 
Either the channel's expiry time is reached and the sender is refunded their coins, or both parties authorise the payment. 
Every payment signed by the sender will increment the coins owed to the receiver and decrement the coins owed to the sender.  
The receiver can close the channel by signing and publishing the payment that pays them the most coins. 
To support bi-directional payments, Decker proposed replace by time lock which decrements the channel's expiry time whenever the payment direction changes.
%This lets the receiver to publish the channel's new balance after receiving coins from the sender before any of their previous payments. 
%Otherwise, the sender could publish a  payment are eligible to be broadcast. 
However both state replacement techniques require the channel to have an expiry time and thus it restricts the total number of transactions that can occur. 
Poon and Dryja proposed a third state replacement technique called replace by revocation for Lightning Channels.  
It requires both parties to authorise each other's copy of the new state before sharing secrets to revoke the previously authorised state. 
It also introduced the concept of a dispute process.
This lets one party to publish a fully authorised state to close the channel and the blockchain provides time for the counterparty to prove the published state is invalid.
If fraud is proven, then the broadcaster is penalised and the counterparty is rewarded all coins in the channel.
After the dispute period has expired, both parties are sent their respective coins according to the final state accepted by the blockchain. 


\paragraph{Payment channels in Ethereum}
Raiden proposed the first payment channel construction for Ethereum which is effectively a pair of replace by incentive channels. 
Every payment increments the total coins owed to the counterparty and closing the channel requires each party to publish the final payment received. 
Afterwards the smart contract computes each party's balance using the offset from the total coins owed to both parties. 
Unlike in Bitcoin, this construction has no expiry time and does not restrict the total number of payments within the channel, but it is still restricted to two parties and its state only considers the balance of both parties. 
%If there is a dispute in the channel, then the blockchain accepts the state with the largest monotonic counter as the latest state. 
%Both parties must increment a counter and sign every new state which is simply the balance of both parties. 

\paragraph{State channels in Ethereum} 

Both Sprites and Perun independently proposed a new state replacement technique called replace-by-version. 
While Sprites proposed a two-party payment channel, it also introduced a state channel construction to support $n$ parties and arbitrary applications. 
Briefly, one party is responsible for proposing a command to transition the state.
All parties compute the state transition and increment a version number for the new state. 
It is only considered authorised after each party has received a signature for the new state from every other party in the channel. 
If one party does not co-operate, then any party can use the signed command (or issue their own command) to self-enforce the state transition via the blockchain using a dispute process. 
%Briefly, one party is responsible for proposing a command to transition the state.
%All parties compute the state transition and increment a version number for the new state. 
%Each party signs the new state and its version. 
%It is only considered authorised after each party has received a signature from every other party in the channel. 
%If one party does not co-operate, then any party can self-enforce the state transition via the blockchain using the dispute process. 
To dispute, one party submits a state, its version and a list of signatures to prove this state was authorised by every party to a smart contract on the blockchain. 
Next the party can trigger the dispute process and the blockchain provides a fixed time for all parties to submit signed commands. 
After the dispute period the smart contract executes the submitted commands and transitions to the new state (and increments its version).  
Any party can cancel the dispute during this fixed time period by submitting an authorised state with a a more recent version. 
Pisa modified this state channel construction such that a commitment (i.e. hash) of the new state is signed instead of the plaintext state. 
As a result, there can be an independent smart contract for the state channel that is application-agnostic. 

\paragraph{Multiple-application state channels}
Perun and Counterfactual channel constructions are designed for two parties and have extended the concept of a state channel in two ways. 
First, they proposed the state within a channel can be organised in a hierarchy to support multiple-applications and an on-chain dispute for one application that does not impact other applications in the channel. 
Second, they proposed virtual channels which allows two parties who have not established a channel to connect with each other using a network of channels. 
This requires all channels along the route to lock up collateral while the virtual channel is open. 
Unlike Sprites, both constructions proposed the dispute process should be used to determine the final state and not to self-enforce a state transition directly. 
This allows the channel to be turned off for a single application and for all future state transitions to be executed via the blockchain. 

\section{State Channel Construction} 

We propose a new smart contract $\statechannel$ and a template of modiciations for an application contract $\appcontract$  to support state channels.
This state channel construction relies on the dispute process model from Sprites/PISA to support $n$ parties and to allow the state channel contract to be application-agnostic. 
However, the dispute process is used to determine the final authorised state and to let the channel to be turned off as proposed by Perun/Counterfactual.
This lets the application's progression to be continued via the blockchain.
%It is used to determine the final state to allow the channel to be turned off and for the smart contract's application to be progressed via the blockchain as proposed by Perun/Counterfactual. 
Our template highlights the minimal modifications required for an application to support state channels and provides a mechanism to lock/unlock the application into a state channel upon approval of all parties. 

\subsection{Overview of Locking and Unlocking an Application}

All users must approve to lock the application using $\applock$.
This disables all functionality within the application contract and instantiates the state channel contract. 
Once locked, all parties execute the application off-chain amongst themselves by proposing  and co-operatively signing the hash of every new state alongside an incremented version. %A state hash is only considered valid when each party has received a signature from every other party. 
The channel can be co-operatively turned off using $\statechannelclose$, or any party can trigger the dispute process using $\statechanneldispute$.
This dispute process provides  a fixed time period  for all parties to publish the state hash with the largest version using $\statechannelsetstate$. 
After the dispute process has expired, any party can resolve the dispute using $\statechannelresolve$.
This turns off the channel, confirms the state hash with the largest version as the accepted state.
When the channel is turned off, any party can unlock the application by submitting the entire state in plaintext using $\appunlock$. 
The application contract hashes submitted state and fetches the final state hash from the state channel contract using $\statechannelgetcommitment$.
It compares both hashes before storing the full state and re-enabling all functionality to permit continuing its progress via the blockchain. 

\subsection{State channel contract}

We provide an overview of the state channel contract before discussing how to instantiate it,  how parties collectively authorise new states off-chain and how the dispute process is used to confirm the final state hash. 

\paragraph{Overview of the state channel contract} 
Figure \ref{fig:statechannel} presents an overview of the state channel contract.
The state channel can be in one of three states which are $\chanstatus := \{\chanon, \chandispute, \chanoff\}$.
All parties can collectively authorise new states for the application when the state channel is set as $\chanstatus := \chanon$.
Any party can trigger a dispute which sets the state as $\chanstatus := \chandispute$ and this provides a fixed time period for all parties to submit an authorised state hash (and its corresponding version).
Once the dispute is resolved or if the channel is closed co-operatively, then the state is set to $\chanstatus := \chanoff$ and this determines the final state hash for the application. 
If the channel is closed using the dispute process, then a record of the dispute is stored which includes the starting time and finishing time for the dispute $\timestart, \timeend$ and the final version $\monotoniccounter$.

%All parties can begin collectively executing the application by signing every new state hash (and its version). 
%A state hash is only considered valid when each party has a signature from every other party. 
%The channel can be closed co-operatively using $\statechannelclose$ if both parties agree. 
%Otherwise if one party aborts and does not sign the state hash, then any party can turn off the channel by triggering a dispute using $\statechanneldispute$.
%This provides a fixed time period between $\timenow$ and $\timedispute$ for all parties to respond using $\statechannelsetstate$ with an authorised state hash (and its corresponding version). 
%Any party can resolve the dispute using $\statechannelresolve$ which sets $\chanstatus := \chanoff$.
%Afterwards the application contract $\appcontract$ can fetch the final state hash $\hstatei$ and its version using $\statechanneldispute$. 
%The dispute starting time and the final version is stored and can be fetched using $\statechannelgetdispute$. 

%$The channel can be closed co-operatively using $\statechannelclose$ if both parties sign 
%\sigma_{\participant} := \sign_{\participant}(\mathsf{''close"},\hstatei, \monotoniccounter, \statechannel)$

%
%
%This command alongside a commitment to the new state and 
%This command alongside a signed state commitment tuple $(\hstateplus,\monotoniccounter+1)$ is sent to the other parties.
%To verify, each party computes the new $\stateinfoplus$ (and its corresponding counter) using the received $\cmd$ before exchanging their signature for the new state commitment. 
%A state commitment is not considered authorised until every party has a signature from every other party in the channel. 
%If one party aborts and does not sign the state commitment, then any party can trigger the dispute process in the state channel. 
%This provides a fixed time period for all parties to submit the latest authorised commitment $h_{i+1}$ alongside a list of signatures $\sigma_{p1},...,\sigma_{pn}$ to the state channel contract.
%Once the dispute process has expired, the commitment $h_{n}$ with the largest monotonic counter is considered the final state and it becomes available for the application contract to fetch. 

\paragraph{Creating the channel} 

The application contract $\appcontract$ is responsible for instantiating the state channel contract with the list of participants $\participant_{1},...,\participant_{n}$ and the dispute timer $\timerdispute$.
The state channel is initially set as $\chanstatus := \chanon$ and as we discuss in the next section all functionality in the application contract will be disabled. 

%The state hash is $\hstatei = \hash(\stateinfoi, \rani, \statechannel)$, where $\stateinfoi$ is the full state and $\ran$ is a blinding nonce. 
%Signing the new state hash is denoted as  $\sigma_{\participant} := \sign_{\participant}(\hstatei, \monotoniccounter)$ where $\monotoniccounter$ is the incremented version for this state hash. 

\paragraph{Authorising off-chain state hashes}
A command $\cmd$ is a function call within the application contract.
Any party can select a command $\cmd$ and propose a new state transition $\stateinfoplus := \mathsf{transition}(\stateinfoi, \cmd)$.
The new state is hashed  with a blinding nonce $\hstateplus = \hash(\stateinfoplus, \ranplus)$ and signed  $\sigma_{\participant} := \sign(\hstateplus,\monotoniccounter+1)$.
To complete the state transition, the proposer sends $\cmd,\hstateplus, \stateinfoplus, \ranplus$ and $\sigma_{\participant}$ to the other parties for their approval.
All other parties in the channel verify the state transition before authorising it. 
To verify, each party re-computes the transition $\stateinfoplus' := \mathsf{transition}(\stateinfoi, \cmd)$ and state hash $\hstateplus' := \hash(\stateinfoplus', \ranplus)$.
Then each party verifies the signature $\verifysig(\participant, (\hstateplus', \monotoniccounter+1), \sigma_{\participant})$ and that the version is the largest received so far. 
If satisfied, each party signs the state hash  $\sigma_{k} := \sign(\hstateplus,\monotoniccounter+1, \statechannel, \appcontract)$ and sends this signature to all other parties. 
A new state hash is only considered valid when each party has received a signature from every other party.  
If one party does not receive all signatures by a local time-out, then this party can trigger the dispute process to turn off the channel, unlock the application and continue its execution via the blockchain. 

\paragraph{Dispute process} 

Any party can trigger the dispute process using $\statechanneldispute$.
This self-enforces the dispute time period $\timestart := \timenow$, $\timeend := \timedispute$ and sets $\chanstatus = \chandispute$. 
All parties can submit the latest state hash, its version and the list of signatures to prove it was authorised) using $\statechannelsetstate$. 
The state channel contract $\statechannel$ only stores $\hstatei$ if it is signed by all parties and it is  has the largest version $\monotoniccounter$ received so far. 
After the dispute period has expired, any party can resolve it using $\statechannelresolve$.
This sets $\chanstatus = \chanoff$, stores a dispute record ($\timestart,\timeend, \monotoniccounter$) and allows the application contract $\appcontract$ to fetch the final state hash $\hstatei$. 

\paragraph{Co-operative close}
All parties can sign 
$\sigma_{\participant} := \sign_{\participant}(\mathsf{''close"},\hstatei, \monotoniccounter, \statechannel)$ and submit it to the state channel using $\statechannelclose$.
This stores the state hash $\hstatei$, its version $\monotoniccounter$ and sets $\chanstatus := \chanoff$. 
No dispute is recorded in the contract. 

\subsection{Application Contract}

We propose a state channel template to modify an application contract. 
The template disables all functionality in $\appcontract$  after instantiating the state channel and re-enables the application to support continuous on-chain execution after turning off the state channel. 
In the following, we provide an overview of the template before discussing the locking and unlocking mechanism. 


\paragraph{Overview of template. } \label{sec:template} 
Figure \ref{fig:appmodify} presents an overview of the application contract template.
After modifications, the application contract must explicitly record a list of participants $\participant_{1},...,\participant_{n}$, a dispute timer $\timerdispute$, whether the state channel has been instantiated  $\instantiated := \{\instantiatedyes, \instantiatedno\}$ and if so it also stores the state channel's address  $\statechannel$. 
All functions within the application require a new pre-condition to check whether the state channel is instantiated and should only permit execution if $\instantiated = \instantiatedno$. 
Finally the application must include two new functions $\applock$ that instantiates the state channel upon approval of all parties and $\appunlock$ that verifies a copy of the full state before re-enabling the application. 


%A dispute time period 
%An explicit list of participants 
%A new boolean (on/off) and a pre-condition for every function in the contract (i.e. only allow function to be used if state channel is off)
%Two new functions: create channel (requires a signature from all parties) and setstate (receive full state, fetch hash, compare, store on-chain and re-enable functionality). 


 
\paragraph{Lock application contract} All parties must agree to create the state channel by signing $(\chanon, \appcontract, \timerdispute, \mathsf{k}$), where $\chanon$ signals turning on the channel, $\mathsf{k}$ is an incremented counter to ensure freshness of the signed message and $\timerdispute$ is the fixed time period for the dispute process. 
Any party can call $\applock$ with the list of signatures $\Sigma_{\participant}$, $\timerdispute$ and $\mathsf{k}$ to turn on the state channel. 
The application contract $\appcontract$ verifies all signatures and that $\mathsf{k}$ represents the largest counter received so far.
If satisfied, $\appcontract$ sets  $\instantiated := \instantiatedyes$ effectively disables all functionality within the application.
Next $\appcontract$ creates the state channel contract $\statechannel$ which sets the list of participants $\participant_{1},...,\participant_{n}$ and the dispute timer $\timerdispute$. 
Finally $\appcontract$ stores the state channel address $\statechannel$. 
 

\paragraph{Unlock application contract}

After the dispute process has concluded in $\statechannel$, one party must send  $\stateinfoi',\rani'$ using $\appunlock$ before the functionality can be re-enabled.
The application contract verifies that $\stateinfoi'$  indeed represents the final state by computing $\hstatei' := \hash(\stateinfoi', \rani')$, fetching the final state hash $\hstatei$ from $\statechannel$ using $\statechannelgetcommitment$ and checking  $\hstatei' = \hstatei$. 
If satisfied, $\appcontract$ stores $\stateinfoi'$ and re-enables all functionality by setting $\instantiated :=  \instantiatedno$. 
Of course, if there is no activity within the state channel, then the state channel contract's dispute process can expiry without a submitted $\hstatei$.
In this case, the application contract verifies the state channel returns $\emptyset$ and re-enables all functionality without modifying the existing state. 


%Notes: While all functionality is disabled on-chain; we need to be careful with how parties execute it off-chain! Not all functionality can be supported off-chain (i.e. contract to contract interaction); so this needs to be considered. 

\section{Battleship within a State Channel} 

%In this section, we propose tow contracts for the game battleship and demonstrate how it can be adopted to support state channels. 
%One battleship game relies on a commitment to every cell in the grid and every ships, while the other battleship game simply has a commitment to every ship. 
%We highlight that our game relies on financial incentives and fraud proofs to self-enforce its integrity as opposed to extensive cryptography.
We provide a high-level overview of the game battleship before proposing how to implement it as a smart contract.  
In our proposed protocol, we demonstrate how to overcome the computational limitation of checking the validity of a player's board using fraud proofs via a challenge-response protocol. 
Afterwards we present how to convert the battleship game to support state channels using the template in Section $\ref{sec:template}$. 
%To play the game requires both parties to commit to a list of ships 
%To overcome the computational limitation of checking the validity of a battleship game, we demonstrate how to use fraud proofs 
%The first contract requires a commitment to every cell in a player's board alongside a list of ship commitments, whereas the second game only relies on a list of ship commitments. 
%Afterwards we discuss how to overcome the computational limitation of checking a full board's validity by relying on a challenge-response protocol. 
%This provides a fixed time period for a player to submit a proof of fraud that the counterparty's board is invalid.
%If the fraud proof is correct (and accepted), then the contract atomically forfeits the counterparty's deposit. 
%Finally we present how to convert both contracts to support state channels using the template in Section \ref{sec:template}. 
%We propose two contracts for the battleship game where one game has a commitment to every cell in the grid $\hcell_{i,j}$ and every ship $\hship_{1},...,\hship_{n}$, where the second game simply has the list of ship commitments. 
%Afterwards, we present the fraud proofs which are compatible with both contracts and how to convert them to support state channels. 

\subsection{Overview of Battleship}

Battleship is a two-player game where each player has a list of ships that are placed on a 10x10 private board. 
Each ship must be marked in a straight line either horizontally or vertically, and ships cannot be placed adjacent to each other.\footnote{Ships must be surrounded by water if there is available space on the board.}.
To minimise long-term storage (and the associated significant gas cost), our contract only relies on a commitment to every player's ship and signed messages exchanged between both parties. 

To set up the game, both parties participate in a cut-and-choose protocol.
Each player commits to $N$ lists of ships using $\battleshipcommit$. 
The counterparty selects one list of ships for the player using $\battleshipselectboard$.
Once selected, each player reveals the remaining $N-1$ list of ships to the counterparty. 
If both parties are satisified that all revealed ships are well-formed, they can signal to begin the game using $\battleshipbegin$, otherwise they may chose to quit using $\battleshipgameover$. 
%In the first contract, each player commits to $N$ boards using $\battleshipcommit$, whereas in the second contract each player simply commits to $N$ lists of ships. 
%Next, the counterparty selects a single board (or a single list of ships) using $\battleshipselectboard$. 
%Then, each player reveals all non-selected boards and list of ships to counterparty and this provides them an opportunity to verify all boards (and list of ships) are well-formed. 
%If each player is satisified, then they signal their desire to begin the game using $\battleshipbegin$ 
%Once the game is set up, both players take turns at shooting the other player's board.
In each turn, the player selects a cell to shoot using $\battleshipattackcell$ and the counterparty must open the cell  within a fixed challenge time period. 
To open, the counterparty reveals if the cell is occupied by water or a ship piece using $\battleshiprevealcell$.
If this shot sinks a full ship, then the counterparty must instead reveal the full ship alongside the cell's opening using $\battleshipsinking$. 
Of course, the player is provided another turn if their shot was successful.
%Throughout the game, the loser may have an opportunity submit a proof of fraud using $\battleshipfraud$ if it is detectable the counterparty's board (or list of ships) is invalid. 

At the end, the winner must reveal their board and every ship's location to the loser using $\battleshiprevealboard$.
The loser has a fixed time period to prove if the winner's board was incorrectly set up using $\battleshipfraud$, otherwise either player can call $\battleshipgameover$ after this fixed time period to finish the game. 

\subsection{Battleship Contract} 

We present each phase of the game, how to establish the contract, the cut-and-choose protocol to begin the game, the turn-based gameplay and finally how the loser is provided an opportunity to prove the winner cheated and thus should not be sent the winnings. 

\paragraph{Game Phases} There are six phases $\gamesetup, \gameattack, \gamereveal,  \gamewinner, \gamefraud, \\ \gamefinished$. 
The $\gamesetup$ phase is responsible for ensuring both players select a single list of ships before agreeing to begin the game. 
Game play transitions between $\gameattack$ and $\gamereveal$ as both players take a turn at shooting the counterparty's ships. 
The game transitions to $\gamewinner$ when one player wins the game and it will transition to $\gamefraud$ once the winner has opened all ship locations.
This provides the loser a fixed time period to submit a proof of fraud that the winner's board is not well-formed or that the winner did not honestly reveal a cell during the game. 
Otherwise, the contract transitions to $\gamefinished$ that allows the winner to claim their winnings and reset the contract. 
% to open  to declare a cell, otherwise the contract transitions to $\gamefinished$. 
%Of course, the contract transitions to $\gamefraud$ if a proof of fraud to detect cheating by the counterparty is provided and we explore this phase further in Section \ref{sec:fraud}. 

\paragraph{Contract establishment} 
The contract is established with the address of both players $\participant_{1},\participant_{2}$ and the challenge timer $\timerchallenge$. 
Both parties can deposit coins during $\gamesetup$ phase before placing their bets.

\paragraph{Prepare list of ships} Both parties participate in a cut-and-choose protocol during $\gamestatus := \gamesetup$. 
Each ship is the tuple $(k,\hship)$, where $k$ is the ship's length and $\hship := \hash(i,j,i\pm,j\pm,r, \mathsf{round}, \participant, \appcontract)$.
Each party computes and signs $N$ list of ships: 

\begin{center}
 $\Sigma_{1}^{N} := \sign_{\participant}(((k_{i,1},\hship_{i,1}),...,(k_{i,n},\hship_{i,n})), \participant, \mathsf{round}, \appcontract)$ 
\end{center}
 
This is sent to the counterparty who is responsible for selecting one list and reserving it for the game by submitting it alongside the corresponding signature using $\battleshipselectboard$. 
The party must open the remaining $N-1$ list of ships to the counterparty which provides an opportunity to check their validity. 
If satisified, each party notifies the contract to begin the game using $\battleshipbegin$ which is an explicit acknowledgement that each party has reviewed all opened list of ships.
If the counter-party does not open any ship lists, then the party can signal their desire to quit  using $\battleshipgameover$.
Finally the game $\mathsf{round}$ is incremented regardless if it continues or not. 

\paragraph{Game-play} \label{sec:gameplayships}
%The game phase transitions several times between $\gameattack$ and $\gamereveal$ as each player has a turn at shooting the counterparty's ships. 
The contract maintains a counter $\mathsf{move}$ which increments after each player has taken their turn. 
In the $\gameattack$ phase, the player challenges the counterparty to open a cell $i,j$ by signing: 

\begin{center}
	$\sigma^{shot}_{\participant} := \sign_{\participant}(i,j, \mathsf{move}, \mathsf{round},\appcontract)$ \\
\end{center}

This message is submitted using $\battleshipattackcell$ which transitions the game phase to $\gamereveal$ and sets a fixed time period $\timechallenge := \timenow + \timerchallenge$ for the counterparty's response. 
The counterparty signs one of two messages depending on whether a ship was sunk:

\begin{center}
	$\sigma^{hit}_{\participant} := \sign_{\participant}(i,j,b,\mathsf{move}, \mathsf{round},\appcontract)$ \\ $\sigma^{sunk}_{\participant} := \sign_{\participant}(i,j,i\pm,j\pm,r,\hship,\mathsf{move}, \mathsf{round},\appcontract)$
\end{center}

The counterparty is responsible for submitting either signed message. 
The first message states if the cell is marked with water $b=0$ or a ship location $b=1$.
It is submitted using $\battleshiprevealcell$.
The second message declares the shot sank a ship and requires the counterparty to open the corresponding ship commitment $\hship$ to $\battleshipsinking$. 
Each party must keep a copy of every signed message\footnote{Every signed message is emitted by the contract and thus it is easily fetchable.} as this can later be used as a proof of fraud as discussed in Section \ref{sec:fraud}.
The game transitions to $\gamewinner$ if one player has declared all their ships sunk. 

\paragraph{End of game} 
After one player has lost the game (or if the contract has detected cheating by the loser as illustrated in Section \ref{sec:fraud}), the winner must open their their remaining ship commitments  using $\battleshiprevealships$.
This provides a fixed time period for the loser to submit a proof of fraud which we present in Section \ref{sec:prooffraud}.
After this time period, the winner can redeem their reward using $\battleshipgameover$ which also transitions the game phase to $\gamefinished$. 
Of course, if both parties have cheated, then the winnings are sent to a pre-determined charity address (or simply burnt). 

\subsection{Checking for Fraud} \label{sec:fraud}

We present the simple integrity checks the contract can perform throughput the game to verify that either party has not cheated. 
These checks are performed whenever a player calls $\battleshipattackcell, \battleshipsinking, \battleshiprevealcell, \battleshiprevealships$.


\paragraph{Exceeded maximum number of moves} 
The contract maintains a counter $\mathsf{move}$ to keep track of the shots taken by both players. 
If $\mathsf{move}$ exceeds the number of cells available on the board, then the contract can confirm that both players have cheated.
This is the case as an honest player will have declared all their ships as sunk after every cell on their board has been opened.
Thus the game should have transitioned to $\gamewinner$ before it exceeds $\mathsf{move}$ and instead it will transition to $\gamefinished$ with no player set as the winner. 

\paragraph{Players only play using valid cells}  
The contract checks if the cell $i,j$ is within the permitted range $0 <= i < 10$ and $0 <= j < 10$ for any signed message received. 

\paragraph{A ship was not placed  horizontally or vertically}
The contract can check whether an opened ship was placed on the board horizontally or vertically. 
To verify, it checks that every location for a ship either has the same $i$ or $j$ co-ordinate, and that $i$ or $j$ is incremented (or decremented) strictly by one for every ship location. 
Finally it also checks the ship's length which is pre-determined by the contract

\subsection{Proof of Fraud}  \label{sec:prooffraud}

Fully validating the entire game within the contract environment would incur unreasonable transaction fees. 
We propose each player can be provided an opportunity submit a proof of fraud that the counterparty has cheated. 
In the following we highlight the fraud proofs that can be verified by the contract. 

\paragraph{Player has shot the same cell twice} 
The contract cannot independently verify if a player has shot the same cell twice as it does not store the opening of cells.
Our game requires each player to sign every cell opening and this allows the counterparty to provide signed evidence that the player has tried to attack the same cell twice.
The counterparty submits this proof of fraud using $\battleshipsamecell$ with the two signed shots $\sigma^{shot}_{\participant},\sigma^{shot'}_{\participant}$, the corresponding $\mathsf{move},\mathsf{move}'$ counters and the cell $i,j$. 
The contract verifies the player signed both shots, both shots are for the same cell, and $\mathsf{move}\neq\mathsf{move}'$. 
This proof of fraud can be submitted to the contract at any point during the game. 

\paragraph{Counterparty was dishonest about a cell opening}
The counterparty has marked a cell $(i,j)$ as water, but an opened $\hship$ states it is a ship location. 
%As previously mentioned, the contract only stores ship openings and the player is required to store every signed cell opening. 
To prove fraud, the player submits the ship identifier $\hship$, the disputed cell location $i,j$ and the signed opening of the cell $\sigma^{hit}_{\participant}$. 
The contract can verify if this cell opening was signed by the counterparty as $b = 0$ and the ship $\hship$ claims to be at $i,j$.   
On the other hand, the counterparty may also mark a cell as a ship location,  but no ships are at that location.
This proof of fraud is similar as the player submits the disputed cell location $i,j$ alongside its signed opening $\sigma^{hit}_{\participant}$.
The contract is satisified if it cannot find a ship that claims to be at that location. 

%\paragraph{Adjacent ships} 
%This fraud proof proves that a ship is not surrounded by water and instead two ships are adjacent to each other (or claim to be at the same location on the board). 
%We only require the ship commitments $\hship_{1},\hship_{2}$ to be opened and the same proof can be used in both contracts. 
%Any party can submit the location $i,j$ for the first ship and $i',j'$ for the second ship.  
%The contract can verify if ships are adjacent by checking whether $i,j$ is within the range $i'\pm1, j'\pm1$ or if they claim to be at the same location $i,j = i',j'$.


\paragraph{Two ships claim to be at  the same cell} 
The cheater has used the same cell for two or more ships.  
The index for both ships and the cell $i,j$ must be submitted to the contract using $\battleshiptwoships$. 
The cotract looks up the co-ordinates for each ship and checks if it claims to be at the same location $i.j$.
This proof is applicable during $\gamefraud$ after all ships are opened by the winner. 
NOTE: Is this implemented yet in the contract? 

\paragraph{Ship was not declared as sunk}
The counterparty did not declare a ship as sunk. 
All signed cell openings $\sigma^{hit}_{\participant,1},...,\sigma^{hit}_{\participant,k}$ and the ship identifier $\hship$ must be submitted to the contract using $\battleshipdeclarednotsunk$. 
This allows the contract to verify that every ship location was opened and this implies the counterparty did not declare the ship as sunk as the final opening should be $\sigma^{sunk}_{\participant}$. 
This proof is applicable during $\gamefraud$ after all ships are opened by the winner. 

\paragraph{Challenge period has expired }
The contract relies on a global clock (i.e. block timestamp or block height) to set a fixed time period $\timerchallenge$ for a player to perform an action (i.e. take a shot, open a cell, open all ships, etc). 
If a player does not respond within this time period, then the counterparty can notify the contract using $\battleshipchallengeexpired$  to check if the challenge period has expired. 


\subsection{Modifications for a State Channel}

We present how to modify the battleship contract before deployment in order to support state channels.
This includes allocating information to be used in the state channel, attaching a new pre-condition to every function in the battleship game, the lock/unlock functionality to instantiate the state channel, and finally a new off-chain contract for verifying every state transition in the channel. 

\paragraph{Applying the application template}
The purpose of our application template outlined in Section \ref{sec:template} is to allocate information for the state channel.
When creating the contract, we set $\instantiated := \instantiatedno$ and store the dispute timer $\timerdispute$.
Both players $\participant_{1},\participant_{2}$ are set for use by the state channel if it is instantiated and the battleship contract maintains (and increments) a counter $\mathsf{chan}_{\mathsf{ctr}}$ to track the number of times this state channel is turned on. 
A new pre-condition $\textbf{discard if}$ $ \instantiated  = \instantiatedyes$ is included in every function\footnote{It is included in $\battleshipbegin, \battleshipgameover, \battleshipattackcell, \battleshiprevealcell, \battleshipsinking, \\ \battleshipfraud, \battleshiprevealboard$ and $\battleshiprevealships$. } and the transaction fails\footnote{A failed transaction reverts all computation and thus does not modify the state of any contract.} if the pre-condition is satisified.
This effectively disables all functionality within the application contract if it is locked and the state channel is turned on. 

\paragraph{Lock and unlock functions} 
The lock function $\battleshipunlock$ requires a signature from each party $\participant_{1},\participant_{2}$ to authorise creating the state channel: 

\begin{center}
	$\sigma^{lock}_{\participant} := \sign_{\participant}(''\mathsf{lock}", \mathsf{chan}_{\mathsf{ctr}}, \mathsf{round}, \battleship)$ 
\end{center}
Once the state channel is turned on, the battleship contract sets $\instantiated := \instantiatedyes$ to signal creating the state channel contract and finally it creates a new state channel contract $\statechannel$ with the list of participants $\participant_{1},\participant_{2}$ and the dispute timer $\timerdispute$. 
On the other hand, the unlock function $\appunlock$ requires the dispute process to be finished in the state channel contract. 
Any party can submit the final game $\stateinfo$ (alongside the nonce $r$).
The battleship contract verifies if it corresponds to the final state hash accepted by the state channel contract using $H(\stateinfo,r)$ == $\statechannelgetcommitment$.
If successful, the full state is stored and the flag $\instantiated$ is set as $\instantiatedno$ which effectively re-enables all functionality in the battleship contract. 

\paragraph{Handling Challenge Timer}\label{sec:timers}
The contract is no longer responsible for deciding or self-enforcing the time $\timechallenge$ on behalf of both parties and we propose two approaches to overcome this issue. 
The time $\timechallenge$ can be set by the player proposing a new state and the counterparty must verify the proposed time is within a range (i.e. a few minutes, or $k$ blocks) before mutually authorising to the new state.
It must also take into account the time it takes to turn off the channel via the dispute process $\timedispute$ and extra time to initiate/settle the dispute $\timerextra$. 
An alternative approach is to use a relative timer such that $\timechallenge$ is not updated by the players within the state channel.
Instead the time $\timechallenge$ is set by the contract once it is re-activated in the blockchain using $\battleshipunlock$ and if the game is in a relevant phase.

\paragraph{Off-chain Contract} 
We propose each player can deploy an \textit{off-chain contract} to a local blockchain in order to replicate execution of all state transitions. 
Any functions with \textit{side effects} (i.e. interact with other contracts or accounts) must be disabled as it is not guranteed that any side-effects will persist when the channel is closed. 
In the case of our battleship contract, we must disable the auxillery functions $\battleshipdeposit$ and $\battleshipwithdraw$ as they send/receive coins from other accounts/contracts. 
To disable, both functions can simply be removed from the off-chain version of the contract. 
Additionally, the off-chain contract can include a new $\battleshipgetstate$ to return the full state and the corresponding state hash $\hstate$ for signing. 

\section{Proof  of Concept Implementation}

We present a proof of concept implementation for our battleship game within a state channel.
The experiment was performed on an Ethereum's private network\footnote{This private network mimics the gas cost of Ethereum's production network.} and the gas costs for our proposed modifications are presented in Table \ref{tab:costs}. 

Our experiment involves three contracts which includes the unmodified battleship contract (Step 1), the modified battleship contract (Step 15) and the state channel contract (Step 16). 
Deploying both the modified and unmodified battleship contract highlights the cost for modifying an application contract to support a state channel is approximately 1 million gas. 
A single game of battleship (Steps 4-9) via the blockchain costs approximately 100 mil gas in the worst-case if each player must attack (and reveal) 200 cells, and in the average case of 30 attacks\footnote{Cite blog post chris found} (and reveals) it costs approximately 20 mil gas. 
Locking the battleship game, creating the state channel and performing the dispute process costs approximately 2 million gas.
Unlocking the battleship game and submitting the entire game state costs 2 million gas. 
Steps 11-14 present the costs for all fraud proofs and only one fraud proof is required to prove the counterparty cheated. 

To verify and authorise states off-chain, each player runs a local blockchain with a copy of the Ethereum Virtual Machine (EVM), instantiates the battleship contract and the current state of the game is set. 
To play a move, each player sends the counterparty a signed transaction that can be executed in their local blockchain. 
Both players execute the transaction, fetch the full state from the battleship contract, hash it, and exchange signatures for the new state hash. 
*How is chris handing the time? The state hash will be different if we rely on t now. 
Every move requires approximately 2 seconds over a network. 


\section{Discussion} 

%\paragraph{Probablistic checking board's integrity} Impacts the UX/fun of the game. i.e. you need to have a randomly allocated board, ruins the fun. Could have a zkSNARK to prove integrity of the board. In fact, due to the commit, reveal and then explicit acknowledgement to begin the game - the game does not need to verify the zkSNARK (or any of the N boards validity). We leave this as future work.  


%\begin{table*}
%	\begin{center}
%		\begin{tabular}[]{l l c c c c c c c }
%			\hline 
%			& Parties& Bi-directional & No Expiry Time & Generic & Side-effects & Independent & Multi-App & Dispute\\
%			\hline 
%			Spilman & 2 & \xmark & \xmark & \xmark & \xmark & \xmark & \xmark& state \\ 
%			DMC & N & \cmark & half & \xmark & \xmark & \xmark & \xmark & state  \\ 
%			Lightning & 2 & \cmark & \cmark & \xmark & \xmark & \xmark & \xmark & state \\ 
%			Raiden & 2 & \cmark & \cmark & \xmark & \xmark & \xmark & \xmark & state\\ 
%			Perun & 2 & \cmark & \cmark & \cmark & \xmark & \xmark & \cmark & state \\ 
%			L4 & 2 & \cmark & \cmark & \cmark & \xmark & \xmark & \cmark & state \\ 
%			Sprites & N & \cmark & \cmark & \cmark & \cmark & \xmark & \xmark  & cmd \\ 
%			Pisa & N & \cmark & \cmark & \cmark & \cmark & \cmark & \xmark  & cmd \\ 
%			THIS & N & \cmark & \cmark & \cmark & \xmark & \cmark & \xmark  & state \\ 
%			\hline 
%		\end{tabular}
%	\end{center}
%	\caption{A comparison of the channel constructions. }
%	\label{table:comparison}
%\end{table*}
%

%\paragraph{Comparison of state channel constructions} 
%We present a comparison of all state channel constructions in Table \ref{table:comparison}

\paragraph{Worst-case scenario for state channels} 

One party can turn off the channel using the dispute process after all parties agree to execute the application off-chain.   
This is problematic as all parties are now committed to executing the entire application via the blockchain.
In the case of battleship, both parties commit to the battleship game using $\battleshipbegin$ and afterwards must play the entire turn-based game via the blockchain. 
Each player may have to publish up to 200 transactions (i.e. 100 attack cells, 100 open cells) to finish the game play which incurs significant transaction fees and may require a prolonged period of time to complete. 
Thus state channels must be strictly viewed as an optimistic scaling solution only if all parties are trusted to co-operate.  
%Our battleship game highlights the worst-case sc

%Griefing - every time we ask counterpartyto reveal commitment - there has to be a fixed time period to do it - similar to real life - there is nothing we can do about it - and due to latency on the network - the game could be dragged out for hours. This provides a benefit to use something like Plasma - where the block latency can be super quick (and thus the counterparty has 5 minutes to reply, and not 1 hour). State channel cant get around this -by definition we always hit the worst case. 

\paragraph{Incorporating command issuance} 
The state channel construction in Sprites allows parties to update the application contract's state without closing the channel.
Any party can update the state channel contract with the latest state and the dispute process is used to receive a command from each party.
After the dispute process has expired, the state transition is performed on-chain as each command is executed in the application contract and this results in a new state for use in the channel. 
This approach allows the state channel to support functionality with side-effects such as depositing/withdrawing coins or interacting with other contracts.
However it also requires the application contract to include a new $\mathsf{AC.transition}$ function that can evaluate the submitted commands.
While it appears compatible with our state channel construction, we have left it as future work to incorporate. 

%\paragraph{Non-attributable problem} 
%As previously mentioned in [towards bitcoin payments]
%Fundamentally, it appears impossible to determine the cause behind a dispute on the blockchain. i.e. one party refuses to sign update; or A just doesnt send B's signature to blokchain and instead sends a previous state.

\paragraph{Funfair dilemma} 
Perun and Counterfactual aim to minimise on-chain state (i.e. a single multi-signature contract) and allow two parties to create/destory multiple applications within a state channel. 
On the other hand, Funfair aims to maximimise on-chain state for a single application. 
Both approaches have an underlying assumption about the likelihood that one party may trigger a dispute and the financial cost of resolving this dispute by sending the full state to the blockchain.
We highlight that state channels introduce new economic attack vectors that must be considered when designing compatible applications.
In fact, this dilemma can be summed up in a single question:

\begin{center}
\textit{Will a player turn off the channel for a \$10 bet if it costs \$100 to complete the dispute process, re-activate the contract and win the bet via the blockchain?} 
\end{center} 

To answer the above question, our empirical evaluation confirms that based on the current state of the Ethereum network, the Funfair is preferable as it minimises the cost of the dispute process. 
This is crucial to reduce the impact of economic attacks to undermine the safety guarantee provided by state channels. We need experiment results to back this up with numbers. 

\paragraph{Disabling side-effects} 
We provide a table in the appendix of commans that must not be available in the off-chain contract as they either rely on the environment or other contracts. 


\paragraph{Application timers} 
As we mentioned in Section \ref{sec:timers}, there is no global clock available for setting time within a state channel as the contract no longer sets $\timechallenge$ on behalf of both parties.
We proposed two approaches where each player updates the time when proposing a new state or the time can be updated after the application contract is re-activated on the blockchain (and the state channel is turned off).  
For the first approach, we observed it requires minimal modification as the timer $\timerchallenge$ is modified to be $\timerchallenge + \timerdispute + \timerextra$ when the state channel is created.
However it also implies players must be cautious to close the channel with sufficient time to complete their move via the blockchain.
On the other hand, while the second approach protects both parties from the time it takes to re-activative the contract, it requires the appplication to be aware that the state channel is turned off and accordingly set the time $\timechallenge$ if the game is in a particular state (i.e. attack). 

\paragraph{Supporting arbitration outsourcing of state channels} 
To alleivate the securiy assumption that all parties must remain online and synchronised with the blockchain to watch for malice disputes, PISA proposed that parties can hire an accountable third party to watch the channel on their behalf. 
Our construction is beneficial to PISA as the state channel contract is independent of the customer's application. 
The accountable third party only requires a signature from every party in the channel $\Sigma_{\participant}$, the state hash $\hstate$ and the monotonic counter $\monotoniccounter$ to resolve disputes on the customer's behalf. 
Additionally,  the accountable third party is only required to verify the bytecode for the state channel contract before accepting a job from the customer. 

\paragraph{Persistent race conditions} 
The gameplay for battleship is turn-based and it is clear which player is responsible for proposing every new state. 
Setting up the game using $\battleshipcommit$ or $\battleshipbegin$ has no order and both players can propose a state transition for the same monotonic counter $i$. 
In this case, both players can use a deterministic rule to resolve the race condition (i.e. $\participant_{1}$ proposed state has priority) as the order of execution has no impact on the game's outcome. 
This highlights that race conditions in the underlying application are reflected in the state channel and can result in the state channel being turned off if the order of execution has an impact on the application's outcome. 

\paragraph{Limitations due to the EVM} 
The mapping data structure in Solidity for the Ethereum contract environment poses problems for the state channel as it is not feasible to simply delete all key-value pairs. 
If a key-value pair is deleted within the state channel (i.e. the value is set to 0), then this over-write must also occur when the full state is sent to the contract. 
Otherwise, there is a risk the deleted key-value pair will persists after the state channel is turned off.
For example, if one party's balance is set to 0 coins in the state channel and this isn't reflected in the on-chain contract after turning off the channel, then the party can withdraw their more coins than they deserve from the contract. 

\paragraph{Applications of state channels} 
A state channel requires all parties to remain on-line to authorise every new state of the application.
This lack of fault tolerance implies that a state channel is only suitable for applications that involve a small set of parties. 
We chose battleship for our experiment as the majority of companies who are pursing state channels at the time of writing have identified gaming as a killer-application and battleship is a good example of a game that would otherwise be unreasonable to execute without a state channel. 
However our experiment demonstrates that state channels may not be compatible for games like battleship as each party runs the risk of performing a significant number of moves via the blockchain to finish the game. 
Instead, state channels appear to be  useful for applications that require a small number of rounds and all parties will repeat the application's execution more than once. 
Some applications in this direction include payments, casino games, boardroom elections and auctions.

\section{Conclusion} 


\newpage 
\appendix



\begin{table}
	\centering
	\begin{tabular}[]{l l c c}
		
		\textbf{Step} & \textbf{Purpose} & \textbf{Gas Cost} & \textbf{\$\$}  \\ 
		\hline
		\multicolumn{4}{c}{Battleship Game} \\
		\hline
		1 & Create BattleshipCon & 13,022,595 & 10.36 \\
		2 & Deposit ($\battleshipdeposit$) & 44,247 & 0.04 \\
		3 & Place bet ($\battleshipplacebet$)& 34,687 & 0.03 \\
		4 & Select counterparty's ships ($\battleshipselectboard$) & 423,042 & 0.34 \\ 
		5a & Ready to play ($\battleshipbegin$) & 47,650 & 0.04 \\
		5b & Do not play ($\battleshipquit$) & 777,610 & 0.6 \\
		6 & Attack ($\battleshipattackcell$) & 69,260 & 0.06 \\
		7a & Reveal cell ($\battleshiprevealcell$) & 73,252 & 0.06 \\
		7b & Reveal ship ($\battleshipsinking$)& 111,372 & 0.09  \\
		8 & Open ships ($\battleshiprevealboard$) & 159,748 & 0.13 \\
		9 & Finish game ($\battleshipfinish$) & 275,521 & 0.22 \\
		10 & Withdraw ($\battleshipwithdraw$) & 37,218 &0.03 \\ 
		11 & Fraud: Ships at same cell ($\battleshiptwoships$) & 280,766 & 0.20\\
		12 & Fraud: Declared not hit ($\battleshipdeclarednothit$) & 284,261 & 0.23 \\
		13 & Fraud: Declared not sunk ($\battleshipdeclarednotsunk$) & 312,471 & 0.24 \\
		13 & Fraud: Attack same cell ($\battleshipsamecell$) & 100,881 & 0.08 \\
		14 & Challenge period expired ($\battleshipchallengeexpired$) &75,349 & 0.06 \\
		\hline
		\multicolumn{4}{c}{State Channel} \\
		\hline
		15 & Create Modified BattleshipCon & 13,022,595 & 10.36 \\
		16 & Lock ($\battleshiplock$) & 995,056 & 0.79 \\
		17 & Trigger dispute ($\statechanneldispute$) & 84,106 & 0.07\\
		18 & Set state hash ($\statechannelsetstate$) & 70,035 & 0.06 \\
		19 & Resolve ($\statechannelresolve$) &89,745 & 0.07 \\
		20 & Co-operative turnoff ($\statechannelclose$) & 90,710 & 0.07 \\
		21a & Unlock ($\battleshipunlock$) & 725,508 & 0.6 \\
		21b & Unlock (No Activity) ($\battleshipunlock$) & 20,915 & 0.02 \\
		\hline
		\multicolumn{4}{c}{Aggregated Statistics} \\
		\hline
		\multicolumn{2}{l}{Turn state channel on and off} &  & \\
		\multicolumn{2}{l}{Average case for game} &  & \\
		\multicolumn{2}{l}{Worst case for game} &  &  \\
		\hline 
	\end{tabular}
	
	\caption{Costs of running the battleship game on-chain and within the state channel}\label{tab:costs}
\end{table}


%
%\section{Commitment to entire board}
%
%One issue with our battleship game is that a player can lie about the opening of their cell. While they can never win the game by doing so; it does allow the player to require the counterparty to potentially shoot every cell on their board. One way to prevent this attack is to require the counterparty to commit to every cell on their board in advance of the game; and have it revealed throughout. The problem is that this requires a merkle tree verification per move or every hash (200) to be stored in the contract directly - thus increasing the game cost in the honest case. 
%
%
%\paragraph{Representing the board}
%
%A cell is represented as $\hcell = H(b, r)$, where  $r$ is a unique nonce and $b$ marks the location as water/ship. 
%Each cell is a leaf in a merkle tree and the root is stored in the contract. 
%
%\paragraph{Opening a cell} 
%
%During the game, the counterparty must open the cell $b,r$ alongside a merkle tree branch to prove that this cell is included in the board. 
%
%\paragraph{Keeping track of hits} The contract can maintain a bit string, and flip a bit every time a specific cell is hit. This can prevent a player hitting the same cell twice. A second bit string can be used to indicate if a cell was marked as "water" or "hit". i.e. look up to see if cell was hit, and then check if it was 0/1 (i.e. water/ship location). 
%
%\paragraph{Benefits and Problems} Prevents players lying during the game (assuming the board is well-formed due to probablistic check). However - it requires a merkle tree verification every move which can be expensive over-time. Also need to self-enforce that the cells and the ship locations match - so all should be revealed at the end of this game - that is a lot of information to send. (i.e. 100 random nonces, 100 b values, etc). 
%
%
%\section{Extension to Battleship Contract}
%
%To avoid the issue of allowing a player to "dos" by lying during the game - we can require the party to commit to every cell on the board. 
%
%root + 7 hashes + 2 + opening. something along those lines. 
%
%(could be merkle tree or just store every cell explicitly) - point is that proof of openin is required. can no longer lie about cell opening, but is it worth the overhead? 
%
%- This prevents loser wasting turns - if they know they are going to lose, theyll simply not reveal their cells correctly and make the winner take up all their turns. 


\begin{figure}[h]
	\begin{boxedminipage}{\columnwidth}
		\begin{center}
			\textsf{State channel contract}{}\\
		\end{center}
		
		$\chanstatus := \bot \\
		\participant  := \emptyset, \appcontract := \bot, \\ \hstate := \bot, \monotoniccounter := 0 \\ \timerdispute := 0, \timenow := 0, \timeend := 0$
		
		\begin{flushleft}
			\constructor($\participant', \timerdispute', \appcontract'$):
			
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{set} $\participant := \participant'$ \\
			\quad \textbf{set} $\timerdispute := \timerdispute'$ \\ 
			\quad \textbf{set} $\appcontract := \appcontract'$ \\
			\quad \textbf{set} $\chanstatus := \chanon$ \\
			
		\end{tabular}
		
		\begin{flushleft}
			\oninput \stringlitt{triggerdispute}($\sigma_{k}$): 
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\chanstatus \neq \chanon$ \\
			\quad \textbf{discard if} $\participant \notin \participant_{k}$ \\
			\quad \textbf{if} $\verifysig(\participant_{k}, (\statechannel, \appcontract, ``\mathsf{dispute}"), \sigma_{k})$ \\
			\quad \quad \textbf{set} $\chanstatus := \chandispute$ \\
			\quad \quad \textbf{set} $\timestart := \timenow$ \\
			\quad \quad \textbf{set} $\timedispute := \timestart + \timerdispute$
			
		\end{tabular}
		
		
		\begin{flushleft}
			\oninput  \stringlitt{setstatehash}($\hstate', \monotoniccounter', \Sigma_{\participant}$):
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\chanstatus = \chanoff$ \\
			\quad \textbf{discard if} $\monotoniccounter' \leq \monotoniccounter$ \\
			\quad \textbf{if} $\verifysig(\participant, (\hstate', \monotoniccounter', \statechannel, \appcontract), \Sigma_{\participant})$ \\
			\quad \quad \textbf{set} $\hstate := \hstate'$ \\
			\quad \quad \textbf{set} $\monotoniccounter := \monotoniccounter'$ \\
		\end{tabular}
		
		\begin{flushleft} 
			\oninput \stringlitt{resolve}(): 
		\end{flushleft}
		\begin{tabular}{l}
		\quad \textbf{discard if} $\chanstatus \neq \chandispute$ \\
		\quad \textbf{discard if} $\timenow < \timeend$ \\
		\quad \textbf{set} $\chanstatus := \chanoff$ 
		\end{tabular}
	
		\begin{flushleft} 
		\oninput \stringlitt{getstatehash}(): 
		\end{flushleft}
		\begin{tabular}{l}
		\quad \textbf{discard if} $\chanstatus \neq \chanoff$ \\
		\quad \textbf{return} $\hstatei$
		\end{tabular}
		
		\begin{flushleft} 
			\oninput \stringlitt{getdispute}(): 
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\chanstatus \neq \chanoff$ \\
			\quad \textbf{return} $(\timenow, \timeend, \monotoniccounter)$
		\end{tabular}
	\end{boxedminipage}
	\caption{The state channel contract. It is responsible for managing the dispute process and determining the final state hash.  Discard fails the transaction execution if the pre-condition is satisfied.} \label{fig:statechannel}
\end{figure}

\begin{figure}
\begin{boxedminipage}{\columnwidth}
	\begin{center}
		\textsf{Template for application contract}{}\\
	\end{center}
	
	$\instantiated := \bot,  \stateinfo := \bot \\ 
	\participant  := \emptyset,  \timerdispute := 0, \\
	\statechannel := \bot, \mathsf{k} := 0$
	
		
	\begin{flushleft}
		\constructor($\participant'$): 
	\end{flushleft}
	\begin{tabular}{l}
		\quad \textbf{set} $\participant := \participant'$ \\
		\quad \textbf{set} $\instantiated := \instantiatedno$ \\
		
	\end{tabular}

	\begin{flushleft}
		\oninput \stringlitt{example}(): 
	\end{flushleft}
	\begin{tabular}{l}
		\quad \textbf{discard if} $\instantiated = \instantiatedyes$ \\
		\quad \_;
		
	\end{tabular}
	
	
	\begin{flushleft}
		\oninput  \stringlitt{lock}($\timerdispute', \Sigma_{\participant}$):
	\end{flushleft}
	\begin{tabular}{l}
		\quad \textbf{discard if} $\instantiated = \instantiatedyes$ \\
		\quad \textbf{if} $\verifysig(\participant,(``\mathsf{instantiate}", \appcontract, \mathsf{k}),\Sigma_{\participant})$ \\
		\quad \quad \textbf{set} $\instantiated := \instantiatedyes$ \\
		\quad \quad \textbf{set} $\mathsf{k} := \mathsf{k} + 1$ \\
		\quad \quad \textbf{set} $\statechannel := \mathsf{StateChannel}(\participant, \timerdispute, \mathsf{this})$
	\end{tabular}
	
	\begin{flushleft} 
		\oninput \stringlitt{unlock}($\stateinfo',\ran'$): 
	\end{flushleft}
	\begin{tabular}{l}
		\quad \textbf{discard if} $\instantiated = \instantiatedno$ \\
		\quad \textbf{if} $\hash(\stateinfo', \ran') = \statechannelgetcommitment()$ \\
		\quad \quad $\instantiated := \instantiatedno$ \\
		\quad \quad $\stateinfo := \stateinfo'$ \\
		\quad \textbf{else if} $\bot = \statechannelgetcommitment()$  \\
		\quad \quad $\instantiated := \instantiatedno$
	\end{tabular}
\end{boxedminipage}

	\caption{The application contract template. The above modifications must be included to support a state channel. It allows all functionality to be disabled when the channel is created and re-enables all functionality after the dispute process when provided with the full state.}\label{fig:appmodify}
\end{figure}

\end{document}
