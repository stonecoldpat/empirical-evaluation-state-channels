\PassOptionsToPackage{usenames}{xcolor}
\PassOptionsToPackage{dvipsnames}{xcolor}
\documentclass{llncs}
\usepackage[utf8]{inputenc}
\usepackage{booktabs} % For formal tables
\usepackage{multirow}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{url}
\usepackage{xspace}
\usepackage{pifont}% http://ctan.org/pkg/pifont
\usepackage{color}
\usepackage{boxedminipage}
\usepackage[ff,sets,keys,primitives,operators]{cryptocode}
\usepackage{framed}
\usepackage[group-separator={,}]{siunitx}
\newcommand\bmmax{2}
\usepackage{bm}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{footnote}
\usepackage{units}
\usepackage{multicol,lipsum}
\colorlet{iomsg}{MidnightBlue}
\colorlet{party}{brown}
\colorlet{entry}{NavyBlue}
\colorlet{string}{BlueViolet}

\newcommand{\instantiated}{\mathsf{instantiated}}
\newcommand{\instantiatedno}{\mathsf{NO}}
\newcommand{\instantiatedyes}{\mathsf{YES}}


\newcommand{\gamestatus}{\mathsf{phase}}
\newcommand{\gameregister}{\mathsf{INIT}}
\newcommand{\gamesetup}{\mathsf{SETUP}}
\newcommand{\gameattack}{\mathsf{ATTACK}}
\newcommand{\gamereveal}{\mathsf{REVEAL}}
\newcommand{\gamewinner}{\mathsf{WIN}}
\newcommand{\gamefraud}{\mathsf{FRAUD}}
\newcommand{\gamefinished}{\mathsf{GAMEOVER}}

\newcommand{\chanstatus}{\mathsf{status}}

\newcommand{\chanon}{\mathsf{ON}}
\newcommand{\chandispute}{\mathsf{DISPUTE}}
\newcommand{\chanoff}{\mathsf{OFF}}

\newcommand{\hready}{\mathsf{hready}}
\newcommand{\hboard}{\mathsf{hboard}}
\newcommand{\hslot}{\mathsf{hslot}}
\newcommand{\hship}{\mathsf{hship}}
\newcommand{\hshiplocation}{\mathsf{hshiplocation}}

%\newcommand{\hash}{\textsf{H}}
\newcommand{\cmd}{\mathsf{cmd}}
\newcommand{\hstate}{\mathsf{hstate}}
\newcommand{\hstatei}{\mathsf{hstate}_{\monotoniccounter}}
\newcommand{\hstateplus}{\ensuremath{\mathsf{hstate}_{\monotoniccounter+1}}}
\newcommand{\hstateminus}{\ensuremath{\mathsf{hstate}_{\monotoniccounter-1}}}
\newcommand{\monotoniccounter}{\mathsf{i}}
\newcommand{\stateinfo}{\mathsf{state}}
\newcommand{\stateinfoi}{\mathsf{state}_{\mathsf{i}}}
\newcommand{\stateinfominus}{\mathsf{state}_{\mathsf{i-1}}}
\newcommand{\stateinfoplus}{\mathsf{state}_{\mathsf{i+1}}}
\newcommand{\participant}{\mathcal{P}}

\newcommand{\rani}{\mathsf{r}_{\mathsf{i}}}
\newcommand{\ran}{\mathsf{r}}
\newcommand{\ranminus}{\mathsf{r}_{\mathsf{i-1}}}
\newcommand{\ranplus}{\mathsf{r}_{\mathsf{i+1}}}

\newcommand{\statechannel}{\mathsf{SC}}
\newcommand{\statechanneldispute}{\mathsf{SC}.\mathsf{trigger}}
\newcommand{\statechannelsetstate}{\mathsf{SC}.\mathsf{setstatehash}}
\newcommand{\statechannelresolve}{\mathsf{SC}.\mathsf{resolve}} 
\newcommand{\statechannelgetcommitment}{\mathsf{SC}.\mathsf{getstatehash}} 
\newcommand{\statechannelgetdispute}{\mathsf{SC}.\mathsf{getdispute}} 

\newcommand{\sign}{\mathsf{Sign}}
\newcommand{\verifysig}{\mathsf{VerifySig}}

\newcommand{\battleship}{\mathsf{BS}}
\newcommand{\battleshipfraud}{\mathsf{BS.fraud}}
\newcommand{\battleshipattackslot}{\mathsf{BS.attackslot}}
\newcommand{\battleshipbegin}{\mathsf{BS.begingame}}
\newcommand{\battleshipcommit}{\mathsf{BS.commit}}
\newcommand{\battleshipselectboard}{\mathsf{BS.select}}
\newcommand{\battleshiprevealslot}{\mathsf{BS.openslot}}
\newcommand{\battleshipsinking}{\mathsf{BS.sunk}}
\newcommand{\battleshiprevealships}{\mathsf{BS.winnerships}}
\newcommand{\battleshiprevealboard}{\mathsf{BS.winnerboard}}
\newcommand{\battleshipgameover}{\mathsf{BS.gameover}}
\newcommand{\battleshipdeposit}{\mathsf{BS.deposit}}
\newcommand{\battleshipwithdraw}{\mathsf{BS.withdraw}}

\newcommand{\battleshipadjacent}{\mathsf{BS.adjacentships}}
\newcommand{\battleshipnotstraightline}{\mathsf{BS.notstraightline}}
\newcommand{\battleshipshipnotplaced}{\mathsf{BS.shipnotplaced}}
\newcommand{\battleshipnotsunk}{\mathsf{BS.declarednotsunk}}

\newcommand{\appcontract}{\mathsf{AC}}
\newcommand{\applock}{\mathsf{AC.lock}}
\newcommand{\appunlock}{\mathsf{AC.unlock}}

\newcommand{\timerchallenge}{\mathsf{\Delta}_{\mathsf{challenge}}}
\newcommand{\timechallenge}{\mathsf{t}_{\mathsf{challenge}}}
\newcommand{\timerdispute}{\mathsf{\Delta}_{\mathsf{dispute}}}
\newcommand{\timenow}{\mathsf{t}_{\mathsf{now}}}
\newcommand{\timestart}{\mathsf{t}_{\mathsf{start}}}
\newcommand{\timeend}{\mathsf{t}_{\mathsf{end}}}
\newcommand{\timedispute}{\timenow + \mathsf{\Delta}_{\mathsf{dispute}}}

% Colorful diagrams 
\newcommand{\constructor}{\textcolor{entry}{\bf constructor }}
\newcommand{\oninput}{\textcolor{entry}{\bf function }}
\newcommand{\stringlitt}[1]{\texttt{\textcolor{string}{#1}}}

\begin{document}


	\title{An empirical evaluation of state channels as a scaling solution for cryptocurrencies}
	\maketitle
	\begin{abstract}
		So-called Layer 2 and Off-chain solutions are heralded as a scaling solution for cryptocurrencies. 
	\end{abstract} 

\section{Introduction}

We propose a new state channel construction that combines the dispute process model from Sprites to support $n$-parties, the ability to turn a channel on/off by requiring the dispute process to determine the latest state commitment from L4/PERUN and finally it incorporates state commitments from PISA such that the dispute process is only responsible for accepting the latest state commitment that was authorised by all parties. 


1. how much has the ethereum foundation invested?
2. how much has the ethereum community fund invested?
3. how many companies exist to have deployed state channels / currently in the works. 



\begin{itemize}
\item A new dispute process that supports any application and ensures quick liveness of the application (i.e. sprites, every command dispute = slow, L4/Perun requires incorporating channel into app)
\item Financial incentives + fraud proofs can be used to avoid elaborate cryptography to build meaningful applications. Can only go so far (i.e. makes sense for battleships as everything is eventually revealed, but not e-voting) 
\item The first empirical evaluation of state channels as a scaling solution. 

\end{itemize}
\section{Background}

\subsection{Ethereum and smart contracts}


A smart contract is a state machine, where the state transition is executed on-chain based on an authorised command. 


\subsection{Evolution of channel constructions}

In Bitcoin - dispute process is to determine latest state and "close" the channel. Awkward to make this work - Lightning relies on revocation/penalty to enforce latest state is broadcast/accepted. 

In Perun/L4 - the dispute process is to determine the latest state and "close" the channel. 

In Sprites - dispute process is to process "commands" such as payments / withdrawals. Useful for single-purpose commands, not great for continuous applications (i.e. gaming) due to dispute process per command.

In Pisa - dispute process extends Sprites, but adds privacy-preserving feature - this allows state channel contract to be independent of the application. 

\section{State Channel Construction} 

%We propose a state channel contract and modifications to an application contract that is required to support the state channel.
We propose a new state channel contract $\statechannel$ and a template of modiciations for an application contract $\appcontract$  to support state channels. 
This modification provides a mechanism for locking (and unlocking) the application into a state channel upon approval of all parties. 

At a high level, the locking mechanism $\applock$ disables all functionality within the application contract and instantiates the state channel contract. 
Once locked, all parties execute the application off-chain amongst themselves by proposing  and co-operatively signing the hash of every new state alongside an incremented counter. 
A state hash is only considered valid when each party has received a signature from every other party. 
To turn off the channel, any party can trigger the dispute process using $\statechanneldispute$ via the state channel contract.
This provides  a fixed time period  for all parties to publish the state hash with the largest monotonic counter using $\statechannelsetstate$. 
After the dispute process has expired, any party can resolve the dispute using $\statechannelresolve$ which turns off the channel, confirms the state hash with the largest monotonic counter as the accepted state, and allows any party to unlock the application contract $\appunlock$. 
To unlock, any party can reveal the state (in plain text) to the application contract and this opening is verified by fetching the final state hash from the state channel contract using  $\statechannelgetcommitment$. 
Once verified, the full state is stored within the application contract and all functionality is re-enabled to permit execution to continue on-chain. 

In the following, we present the new state channel contract and the modifications required to an application contract. 


\subsection{State channel contract}

%\paddy{I'd like to add "commands" into the state channel; so we can add/remove new participants (or withdraw coins) without turning off the channel. Basic SPRITES construction! }

%The state channel contract manages the dispute process and it is responsible for determining the state commitment that is used by the application contract before its functionality is re-enabled to permit on-chain state transitions. 
We provide an overview of the state channel construction before discussing how to set it up, how participants authorise state transitions off-chain and how the dispute process confirms the final state hash. 

\paragraph{Overview of the state channel contract} 
Figure \ref{fig:statechannel} presents an overview of the state channel contract. 
It contains a list of parties $\participant_{1},...,\participant_{n}$, a dispute timer $\timerdispute$, the application contract's address $\appcontract$ and a  $\chanstatus = \{\chanon, \chandispute, \chanoff\}.$

Upon creation, the contract is set as $\chanstatus := \chanon$ and all parties can collectively execute the application by signing every new state hash (and an incremented nonce).
This is denoted as $\sigma_{\participant} := \sign_{\participant}(\hstatei, \monotoniccounter)$, where  $\hstatei = \hash(\stateinfoi, \rani)$ is the state hash ($\ran$ is a nonce) and $\monotoniccounter$ is an incremented monotonic counter. 
A state hash is only considered valid when each party has a signature from every other party. 
If one party aborts and does not sign the state hash, then any party can turn off the channel by triggering a dispute using $\statechanneldispute$ which sets $\chanstatus := \chandispute$. 

This provides a fixed time period between $\timenow$ and $\timedispute$ for all parties to respond using $\statechannelsetstate$ with $\hstate$, its monotonic counter $\monotoniccounter$ and a corresponding signature from every party $\Sigma_{\participant}$. 
Afterwards, any party can resolve the dispute using $\statechannelresolve$ which sets $\chanstatus := \chanoff$ and allows the final $\hstatei$ to be fetched by $\appcontract$ using  $\statechannelgetcommitment$. 
Finally the dispute time period and the final counter is recorded which can later be fetched using $\statechannelgetdispute$. 
%
%
%This command alongside a commitment to the new state and 
%This command alongside a signed state commitment tuple $(\hstateplus,\monotoniccounter+1)$ is sent to the other parties.
%To verify, each party computes the new $\stateinfoplus$ (and its corresponding counter) using the received $\cmd$ before exchanging their signature for the new state commitment. 
%A state commitment is not considered authorised until every party has a signature from every other party in the channel. 
%If one party aborts and does not sign the state commitment, then any party can trigger the dispute process in the state channel. 
%This provides a fixed time period for all parties to submit the latest authorised commitment $h_{i+1}$ alongside a list of signatures $\sigma_{p1},...,\sigma_{pn}$ to the state channel contract.
%Once the dispute process has expired, the commitment $h_{n}$ with the largest monotonic counter is considered the final state and it becomes available for the application contract to fetch. 

\paragraph{Creating the channel} 

The application contract $\appcontract$ is responsible for instantiating the state channel contract and providing it with the list of participants $\participant_{1},...,\participant_{n}$, the dispute timer $\timerdispute$, the address $\appcontract$ and setting $\chanstatus := \chanon$. 
As we discuss in the next section, all functionality in the application contract is disabled after the state channel contract is created. 

\paragraph{Authorising off-chain state hashes}
A command $\cmd$ is a function call within the application contract.
Any party can select a command $\cmd$ and propose a new state transition $\stateinfoplus := \mathsf{transition}(\stateinfoi, \cmd)$.
The new state is hashed  $\hstateplus = \hash(\stateinfoplus, \ranplus)$ and signed  $\sigma_{\participant} := \sign(\hstateplus,\monotoniccounter+1)$.
To finalise the state transition, the proposer sends $\cmd,\hstateplus, \stateinfoplus, \ranplus$ to all other parties for their approval.

All other parties in the channel verify the state transition before authorising it. 
To verify, each party re-computes the state transition $\stateinfoplus' := \mathsf{transition}(\stateinfoi, \cmd)$ and the state hash $\hstateplus' := \hash(\stateinfoplus', \ranplus)$.
Then, each party verifies the received signature $\verifysig(\participant, (\hstateplus', \monotoniccounter+1), \sigma_{\participant})$ and that the counter is the largest received so far. 
If satisfied, each party signs the state hash  $\sigma_{k} := \sign(\hstateplus,\monotoniccounter+1, \statechannel, \appcontract)$ and sends their signature alongside the state information $\cmd,\hstateplus, \stateinfoplus, \ranplus, \sigma_{k}$ to all other parties. 

The new state hash is only considered valid when each party has received a signature from every other party.  If one party does not receive all signatures within a local time-out, then this party can trigger the dispute process to turn off the channel and continue the application's execution on-chain. 

\paragraph{Dispute process.} 

Any party can trigger the dispute process using $\statechanneldispute$ which self-enforces a time period $\timestart := \timenow$, $\timeend := \timedispute$ and sets $\chanstatus = \chandispute$. 
Any party can submit the latest state hash (alongside a signature from every party $\Sigma_{\participant})$ during the dispute period using $\statechannelsetstate$. 
The state channel contract $\statechannel$ only stores the $\hstatei$ if it is  signed by all parties within the state channel and it is  associated with the largest $\monotoniccounter$ received so far. 
After the dispute period has expired, any party can resolve it using $\statechannelresolve$ which sets $\chanstatus = \chanoff$, stores a dispute record ($\timestart,\timeend, \monotoniccounter$) and allows the application contract $\appcontract$ to fetch the final state hash $\hstatei$. 

\subsection{Application Contract}

We propose a state channel template to modify an application contract. 
The template disables all functionality in $\appcontract$  after instantiating the state channel and re-enables the application to support continuous on-chain execution after turning off the state channel. 
In the following, we provide an overview of the template before discussing the locking and unlocking mechanism. 


\paragraph{Overview of template. } \label{sec:template} 
Figure \ref{fig:appmodify} presents an overview of the application contract template.
After modifications, the application contract must explicitly record a list of participants $\participant_{1},...,\participant_{n}$, a dispute timer $\timerdispute$, whether the state channel has been instantiated  $\instantiated := \{\instantiatedyes, \instantiatedno\}$ and if so it also stores the state channel's address  $\statechannel$. 
All functions within the application require a new pre-condition to check whether the state channel is instantiated and should only permit execution if $\instantiated = \instantiatedno$. 
Finally the application must include two new functions $\applock$ that instantiates the state channel upon approval of all parties and $\appunlock$ that verifies a copy of the full state before re-enabling the application. 


%A dispute time period 
%An explicit list of participants 
%A new boolean (on/off) and a pre-condition for every function in the contract (i.e. only allow function to be used if state channel is off)
%Two new functions: create channel (requires a signature from all parties) and setstate (receive full state, fetch hash, compare, store on-chain and re-enable functionality). 


 
\paragraph{Lock application contract} All parties must approve to instantiating the state channel by signing $(\chanon, \appcontract, \timerdispute, \mathsf{k}$), where $\chanon$ signals turning on the channel, $\mathsf{k}$ is an incremented counter to ensure freshness of the signed message and $\timerdispute$ is the fixed time period for the dispute process. 
Any party can call $\applock$ with the list of signatures $\Sigma_{\participant}$, $\timerdispute$ and $\mathsf{k}$ to turn on the state channel. 
The application contract $\appcontract$ verifies all signatures and that $\mathsf{k}$ represents the largest counter received so far.
If satisfied, $\appcontract$ sets  $\instantiated := \instantiatedyes$ effectively disables all functionality within the application.
Next $\appcontract$ creates the state channel contract $\statechannel$ which sets the list of participants $\participant_{1},...,\participant_{n}$ and the dispute timer $\timerdispute$. 
Finally $\appcontract$ stores the state channel address $\statechannel$. 
 

\paragraph{Unlock application contract}

After the dispute process has concluded in $\statechannel$, one party must send  $\stateinfoi',\rani'$ using $\appunlock$ before the functionality can be re-enabled.
The application contract verifies that $\stateinfoi'$  indeed represents the final state by computing $\hstatei' := \hash(\stateinfoi', \rani')$, fetching the final state hash $\hstatei$ from $\statechannel$ using $\statechannelgetcommitment$ and checking  $\hstatei' = \hstatei$. 
If satisfied, $\appcontract$ stores $\stateinfoi'$ and re-enables all functionality by setting $\instantiated :=  \instantiatedno$. 
Of course, if there is no activity within the state channel, then the state channel contract's dispute process can expiry without a submitted $\hstatei$.
In this case, the application contract verifies the state channel returns $\emptyset$ and re-enables all functionality without modifying the existing state. 


%Notes: While all functionality is disabled on-chain; we need to be careful with how parties execute it off-chain! Not all functionality can be supported off-chain (i.e. contract to contract interaction); so this needs to be considered. 

\section{Battleship within a State Channel} 

%In this section, we propose tow contracts for the game battleship and demonstrate how it can be adopted to support state channels. 
%One battleship game relies on a commitment to every slot in the grid and every ships, while the other battleship game simply has a commitment to every ship. 
%We highlight that our game relies on financial incentives and fraud proofs to self-enforce its integrity as opposed to extensive cryptography.
We provide a high-level overview of the battleship game before proposing two smart contracts. 
The first contract requires a commitment to every slot in a player's board alongside a list of ship commitments, whereas the second game only relies on a list of ship commitments. 
Afterwards we discuss how to overcome the computational limitation of checking a full board's validity by relying on a challenge-response protocol. 
This provides a fixed time period for a player to submit a proof of fraud that the counterparty's board is invalid.
If the fraud proof is correct (and accepted), then the contract atomically forfeits the counterparty's deposit. 
Finally we present how to convert both contracts to support state channels using the template in Section \ref{sec:template}. 
%We propose two contracts for the battleship game where one game has a commitment to every slot in the grid $\hslot_{i,j}$ and every ship $\hship_{1},...,\hship_{n}$, where the second game simply has the list of ship commitments. 
%Afterwards, we present the fraud proofs which are compatible with both contracts and how to convert them to support state channels. 

\subsection{Overview of Battleship Contracts}

Battleship is a two-player game where each player has a list of ships and a 10x10 private board. 
Each ship must be marked in a straight line either horizontally or vertically, and ships cannot be placed adjacent to each other.\footnote{Ships must be surrounded by water if there is available space on the board.}.

To set up the game, both parties participate in a cut-and-choose protocol.
Each player commits to a list of $N$ boards (or $N$ lists of ships) using $\battleshipcommit$. 
The counterparty selects one board (or list of ships) for the player using $\battleshipselectboard$.
Once selected, each player reveals the remaining $N-1$ boards (or list of ships) to the counterparty. 
If both parties are satisified that all revealed boards are well-formed, they can signal to begin the game using $\battleshipbegin$, otherwise they may chose to quit using $\battleshipgameover$. 

%In the first contract, each player commits to $N$ boards using $\battleshipcommit$, whereas in the second contract each player simply commits to $N$ lists of ships. 
%Next, the counterparty selects a single board (or a single list of ships) using $\battleshipselectboard$. 
%Then, each player reveals all non-selected boards and list of ships to counterparty and this provides them an opportunity to verify all boards (and list of ships) are well-formed. 
%If each player is satisified, then they signal their desire to begin the game using $\battleshipbegin$ 
%Once the game is set up, both players take turns at shooting the other player's board.
In each turn, the player selects a slot to shoot using $\battleshipattackslot$ and the counterparty must open the slot  within a fixed challenge time period. 
To open, the counterparty reveals if the slot is occupied by water or a ship piece using $\battleshiprevealslot$.
If this shot sinks a full ship, then the counterparty must instead reveal the full ship alongside the slot's opening using $\battleshipsinking$. 
The slot's opening (and if a ship was sunk) is recorded in the contract. 
Of course, the player is provided another turn if their shot was successful.
Throughout the game, the loser may have an opportunity submit a proof of fraud using $\battleshipfraud$ if it is detectable the counterparty's board (or list of ships) is invalid. 

At the end, the winner must reveal their board and every ship's location to the loser using $\battleshiprevealboard$.
The loser has a fixed time period to prove if the winner's board was incorrectly set up using $\battleshipfraud$, otherwise either player calls $\battleshipgameover$ to finish the game. 


\subsection{Setting up battleship game} 

We present the game phases, the data structures to represent board and list of ships, and how to register each player. 
Both contracts  $\mathsf{BattleshipCon1}$ and $\mathsf{BattleshipCon2}$ have the same game life-cycle and game mechanics.
However as we present afterwards, the former relies on a commitment to the entire board and every ship, whereas the latter only relies on a commitment to every ship. 


\paragraph{Game Phases} There are six phases $\{\gamesetup, \gameattack, \gamereveal,  \gamewinner, \gamefraud, \\ \gamefinished\}$. 
The contract is established  with an initial deposit from both players and the challenge timer which dicates the length of time each player has to respond. 
The $\gamesetup$ phase is responsibe for selecting a single board and/or a list of ships for each player before the game begins.
Game play involves several transitions between $\gameattack$ and $\gamereveal$ as both players take a turn at shooting the counterparty's ships. 
The game transitions to $\gamewinner$ when one player wins the game. 
This requires the winner to reveal their board and the corresponding list of ships. 
The loser is provided with a fixed time period to submit a proof of fraud that the winner's board is not well-formed, otherwise the contract transitions to $\gamefinished$. 
Of course, the contract transitions to $\gamefraud$ if a proof of fraud to detect cheating by the counterparty is provided and we explore this phase further in Section \ref{sec:fraud}. 

\paragraph{Representing the board and ships} 
%All slot and ship locations include a unique nonce $r$. 
A board is a 10x10 grid and each slot is represented as $\hslot_{i,j} := \hash(b, r, \mathsf{round}, \participant, \appcontract)$, where $i,j$ is the slot position, $b$ indicates if it is marked as a ship location.
Each ship is the tuple $(k,\hship)$, where $k$ is the ship's length and $\hship := \hash(i,j,i\pm,j\pm,r, \mathsf{round}, \participant, \appcontract)$.
%Each player has a list of ships $(k,\hship),...,(k',\hship')$ and the full board eis represented:

%\begin{center}
%$\hboard := \hash(\hslot_{0,0},...,\hslot_{10,10},(k_{1},\hship_{1}),..,(k_{n},\hship_{n}), \mathsf{round}, \participant, \appcontract)$
%\end{center}

%Where the game $\mathsf{round}$ is a monotonic counter and $\participant$ is this party's address. 

\paragraph{Game setup and registration} 
The contract is established with the address of both players $\participant_{1},\participant_{2}$ and the challenge timer $\timerchallenge$. 
Both parties can deposit coins during $\gamesetup$ phase before placing their bets. 

%\paragraph{TODO: Each player can have a clock} - to force an upper bound on game length. i.e. 500 blocks to finish the game issue = congestion can mess up game. 

\subsection{BattleshipCon1: Board and  a list of ships } 

This contract relies on $\hboard$ which includes a commitment to every slot in the grid and a list of ships. 
%As we discuss later in Section x, this allows both players to detect and prove if the counterparty is cheating.  
We present how each player selects one board for the game, the turn-based game play and finally how the loser is provided an opportunity to validate the winner's board before the winnings are sent. 

\paragraph{Prepare battleship board} Both parties participate in a cut-and-choose protocol during $\gamestatus := \gamesetup$. 
Each party computes and individually signs $N$ boards: 

\begin{center}
	$\sigma^{board}_{\participant} := \sign_{\participant}(\hslot_{0,0},...,\hslot_{10,10},(k_{1},\hship_{1}),..,(k_{n},\hship_{n}), \mathsf{round}, \participant, \appcontract)$
\end{center}

All signed boards are sent to the counterparty who selects one board and reserves it for the game by submitting the signed board using $\battleshipselectboard$. 
After selecting a board, the party opens the remaining $N-1$ boards to the counterparty who checks the validity of each board. 
If satisified, each party notifies the contract to begin the game using $\battleshipbegin$ which is as an explicit acknowledgement that the party has reviewed the remaining boards from the counterparty.
If the counter-party does not reveal any boards (or if they are invalid), then the party can signal their desire to quit  using $\battleshipgameover$.\footnote{The counter-party can be forced to reveal every board on-chain to test its validity and potentially forfeit their deposit, but this is prohibitively expensive for $N-1$ boards.}
Finally the game $\mathsf{round}$ is incremented regardless if it continues or not. 

\paragraph{Game-play} \label{sec:gameplay}
%The game phase transitions several times between $\gameattack$ and $\gamereveal$ as each player has a turn at shooting the counterparty's ships. 

In the $\gameattack$ phase, the player challenges the counterparty to reveal a slot $i,j$ using $\battleshipattackslot$.
This transitions the game phase to $\gamereveal$ and sets a fixed time period $\timechallenge := \timenow + \timerchallenge$.
If the counterparty's ship is not sunk, then they submit $(b,r)$ to open $\hslot_{i,j}$ using $\battleshiprevealslot$. 
Otherwise if this shot sinks a ship, then the counter-party submits $(b,r)$ to open $\hslot_{i,j}$ and $(i,j)(i\pm,j\pm,r)$ to open $\hship$ using $\battleshipsinking$. 
The contract $\appcontract$ stores the slot opening, the ship opening and marks the ship as sunk. 
The game transitions to $\gamefraud$ if either player exceeds the maximum number of possible moves or it transitions to $\gamewinner$ if one player has declared all their ships sunk. 

\paragraph{End of game} 

The winner must first open the remaining ships using $\battleshiprevealships$ and the contract verifies if all slots for any of the remaining ships have been revealed (i.e. the winner has not declared them as sunk). 
Afterwards, the winner opens the remaining slots of their board using $\battleshiprevealboard$. 
No further validation is performed by the contract and a fixed time period is enforced to permit time for the loser to submit a proof of fraud using $\battleshipfraud$.
After this time period, the winner can redeem their reward using $\battleshipgameover$ which also transitions the game phase to $\gamefinished$. 

\subsection{BattleshipCon2: List of ships } 

This contract only relies on ship commitments  $\hship_{1},...,\hship_{n}$. 
%As we discuss in Section x, this reduces the storage requirements to play the game, but increases the difficulty for players to detect fraud during the game. 
We present how each player selects one list of ships, the turn-based game play and finally how the loser is provided an opportunity to validate the winner's list of ships before the winngs are sent. 

\paragraph{Prepare list of ships} Both parties participate in a cut-and-choose protocol during $\gamestatus := \gamesetup$. 
Each party computes  and signs $N$ list of ships: 

\begin{center}
 $\Sigma_{1}^{N} := \sign_{\participant}(((k_{i,1},\hship_{i,1}),...,(k_{i,n},\hship_{i,n})), \participant, \mathsf{round}, \appcontract)$ 
\end{center}
 
This is sent to the counterparty who is responsible for selecting one list and reserving it for the game by submitting the list of ships (alongside the corresponding signature) using $\battleshipselectboard$. 
The party must reveal the remaining $N-1$ list of ships which allows the counterparty to check their validity. 
If satisified, each party notifies the contract to begin the game using $\battleshipbegin$ which is an explicit acknowledgement that each party has reviewed all revealed ships.
If the counter-party does not reveal any ships, then the party can signal their desire to quit  using $\battleshipgameover$.
Finally the game $\mathsf{round}$ is incremented regardless if it continues or not. 

\paragraph{Game-play} \label{sec:gameplayships}
%The game phase transitions several times between $\gameattack$ and $\gamereveal$ as each player has a turn at shooting the counterparty's ships. 

In the $\gameattack$ phase, the player challenges the counterparty to reveal a slot $i,j$ using $\battleshipattackslot$.
This transitions the game phase to $\gamereveal$ and sets a fixed time period $\timechallenge := \timenow + \timerchallenge$ for the counterparty's response. 
In this contract, there is no commitment to a slot in the grid $\hslot_{i,j}$.
Instead the counterparty signs one of two messages depending on whether a ship was sunk:

\begin{center}
	$\sigma^{shot}_{\participant} := \sign_{\participant}(i,j,b,\participant,\mathsf{round},\appcontract)$ \\ $\sigma^{sunk}_{\participant} := \sign_{\participant}(i,j,i\pm,j\pm,r,\hship,\participant,\mathsf{round},\appcontract)$
\end{center}

The first signed message identifies if the slot is marked with water or a ship location, and it is submitted using $\battleshiprevealslot$.
Whereas the second signed message declares a ship was sunk by opening a ship commitment, and it is submitted using $\battleshipsinking$. 
The counterparty is responsible for submitting the signed message and the contract only stores a ship opening. 
Each party must keep a copy of every signed message \footnote{Every signed message is submitted to the contract and thus can be fetched from the counterparty's transaction.} as this can later be used as a proof of fraud as discussed in Section \ref{sec:fraud}.
The game transitions to $\gamefraud$ if the either player exceeds the maximum number of possible moves or it transitions to $\gamewinner$ if one player has declared all their ships sunk. 

\paragraph{End of game} 

The winner opens all ships using $\battleshiprevealships$ and the contract does not validate the ships. 
A fixed time period is enforced to permit time for the loser to submit a proof of fraud using $\battleshipfraud$.
After this time period, the winner can redeem their reward using $\battleshipgameover$ which also transitions the game phase to $\gamefinished$. 
%,(i,j)$  
%the signed message $\sign_{\participant}((b, r), (i, j), \instantiatedno, \appcontract)$.

%$\sign_{\participant}((b, r), (i, j), \instantiatedyes, $ $(r_{1},...,r_{k}), \appcontract)$, where $r_{1},...,r_{k}$ are the nonces required to open $\hshiplocation_{1},...,$ $\hshiplocation_{k}$. 

\subsection{Proof of Fraud} \label{sec:fraud}

Both contracts rely on players submitting a proof of fraud if an invalid board, list of ships or move is publicly detected. 
This is necessary as validating the board or list of ships is a computationally expensive searching problem. 
%We highlight that the contract cannot process the opening of a slot or ship if the input values are not correctly formatted (i.e. the pre-image of a hash must be in a particular order). 
%Thus, a cheating player can never win the game if an opening is not well-formed. 
We present five fraud proofs that can be submitted if either player attempts to cheat.
%In the following, we highlight how all data within a commitment must be well-formed to win the game before presenting four proof of frauds which focus on the information stored within a commitment and can be used if either player attempts to cheat.  
%The game relies on each player submitting a proof of fraud using $\battleshipfraud$ if an invalid board (or list of ships) is publicly detected.%
%This is necessary as validating the board (and the list of ships) is a computationally expensive searching problem.\footnote{TODO: Can we get some evidence? or at least some intuition how long it takes? https://stackoverflow.com/questions/7501344/how-to-validate-battleship-field }  
%In the following, we highlight all committed data must be well-formed in order to win the game and thus we present four fraud proofs which focus on the revealed data's integrity. 

% our fraud proofs focus on the integrity of the committed data.  the committed data must be correctly formatted in order to win the game before presenting four fraud proofs which will convince $\appcontract$ that can be submitted to the contract which demonstrate that the revealed board or its corresponding list of ships are not well-formed. 

%\paragraph{Slots or ship locations are not formatted correctly} 

%As a result, our fraud proofs focus on information stored within a correctly formatted pre-image of a hash and proves if the game logic was violated.
%For example, the list of positions within a $\hshiplocation$ must correspond to a marked location on the board. 

\paragraph{Ships are not placed on the board}
This fraud proof proves a ship location $(i,j)$ for an opened $\hship$ is not reflected as a ship location within the corresponding slot $i,j$.
Of course, both contracts initially check if the claimed slot $i,j$ is within the permitted range $0,0...,10,10$. 

In $\mathsf{BattleshipCon1}$, the contract stores every slot and ship opening. 
Any player can submit the ship identifier $\hship$ and the disputed slot location $i,j$.
The contract verifies if $i,j$ was marked as a ship location and if the opening of $\hship$ claims to be at $i,j$. 

In $\mathsf{BattleshipCon2}$, the contract only stores the ship opening and the player is required to store every signed slot opening. 
One player submits the ship idenfitier $\hship$, the disputed slot location $i,j$ and the signed opening of the slot $\sigma^{shot}_{\participant}$. 
The contract verifies if this slot opening was signed by the counterparty,  $b = 0$ and the ship $\hship$ claims to be at $i,j$.   

\paragraph{Erroneously marked  slot as a ship location} 
This fraud proof proves a slot was marked as a ship location, but none of the opened ships claim to be at that location.
All ships must be opened before this fraud proof can be used. 

In $\mathsf{BattleshipCon1}$, the contract stores every slot and ship opening. 
One player submits the disputed location $i,j$ is submitted and the contract verifies if any ships claim to be at that location. 

In $\mathsf{BattleshipCon2}$, the contract stores every ship opening.
One player submits the disputed slot location $i,j$ alongside its signed opening $\sigma^{shot}_{\participant}$. 
Again, the contract verifies the signed opening before verifying if any slots claim to be at that location. 

Furthermore, the counter may keep track of the number of successful shots by incrementing a counter $\mathsf{hit}_{\participant}$. 
If there are more successful hits than expected ship locations on the board, then the contract can automatically detect fraud. 

\paragraph{Adjacent ships} 
This fraud proof proves that a ship is not surrounded by water and instead two ships are adjacent to each other (or claim to be at the same location on the board). 
We only require the ship commitments $\hship_{1},\hship_{2}$ to be opened and the same proof can be used in both contracts. 
Any party can submit the location $i,j$ for the first ship and $i',j'$ for the second ship.  
The contract can verify if ships are adjacent by checking whether $i,j$ is within the range $i'\pm1, j'\pm1$ or if they claim to be at the same location $i,j = i',j'$.

\paragraph{Ships not placed horizontally or vertically} 
This fraud proof proves that a ship is not placed on the board horizontally or verifically.
As well, it proves the ship is not placed in a straight line. 
The disputed ship must be opened before this fraud proof can be used and it is the same for both contracts.
The contract verifies that every location for a ship either has the same $i$ or $j$ co-ordinate, and that $i$ or $j$ is incremented (or decremented) strictly by one for every ship location. 

\paragraph{Ship was not declared as sunk}
This fraud proof proves the counterparty did not declare a ship as sunk which can effectively waste the player's next turn. 
The proof requires a line of slot openings marked as ship locations and optionally  up to two additional slots marked as water before/after this line. 
It also requires the counterparty not to have declared the ship as sunk while opening the corresponding. 

In $\mathsf{BattleshipCon1}$, this proof of fraud can be provided during the game. 
As well, the contract automatically checks for this fraud when the winner opens their remaining unsunk ships using $\battleshiprevealships$. 

For proving fraud during the game, if the cut-and-choose protocol was successful, then the counterparty's board is well-formed and every slot opening reveals whether it is marked with water or a ship location. 
Furthermore, the contract stores every slot opening and the ship must be opened at the time of its sinking. 
Thus, one party can potentially prove fraud during the game by submitting the ship locations $(i,j),(i\pm,j\pm)$, and one/two additional water locations $(i',j'),(i'',j'')$ which are directly before and/or after the ship locations. 
The contract verifies each slot is marked as a ship location, and the first/ last ship locations are surrounded by water. 
Next, it checks for any opened ships so far which claim to be at the location $(i,j),(i\pm,j\pm)$. 
Of course, if an opened ship cannot be found, then fraud is proven.

In $\mathsf{BattleshipCon2}$, there is no commitment to any slot on the board and thus there is no guarantee the counterparty will honestly reveal the true opening of a slot. 
However the counterparty is required to provide the party with a signed opening of every slot $\sigma^{shot}_{\participant}$ or $\sigma^{ship}_{\participant}$ if a ship is sank. 
In the event the counterparty does not declare a ship sunk, then the player has a signed slot opening for every ship location. 
All signed slot openings $\sigma^{shot}_{\participant,1},...,\sigma^{shot}_{\participant,k}$ and the ship identifier $\hship$ can be submitted during the phase $\gamewinner$ after all ship commitments are opened.
The contract verifies that every ship location for $\hship$ was indeed opened and the counterparty did not declare it as sunk. 

%At the time of reveal, the counterparty must also specift whether this shot has sunk the ship which updates the slot as  sinking tile. 

% $\hslot$  in the contract is marked as hit if a ship was hit, but not declared as sunk, then the contract the counterparty signs a reveal message 
%$\sign_{\participant}(b, r, i, j, \instantiatedno, \appcontract)$.


%Assuming all signed messages are stored by the non-cheating player, then there are two cases when they can be used.
%In the first case, the player can finish the game early if their shots reveals two slots which are marked as water before and after a ship which has not been declared as sunk.
%The player can provide $\battleshipnotsunk$ with the list of signed reveal messages from the counterparty which indicates the ship was not sunk and the two additional slots marked as water. 
%The contract can simply verify the two slots are indeed before and after the ship, and that the counterparty did not declare their ship as sunk after all successful shots.
%In the second case, the additional two slots are not required when $\gamestatus := \gamewinner$ as the full board (and list of ships) are revealed. 
%The player can simply provide the list of signed reveal messages from the counterparty and identify which ship was sunk. 
%The contract can verify the counterparty did not declare the ship as sunk, but the ship was indeed fully hit. 

%partially revealed board demonstrates 
%Crucially, this fraud proof is also valid in $\gamestatus := \gamewinner$ after the winner's board is revealed. 

%Attack: In reality, after hitting a bit of the ship - it could have sunk. The counterparty can lie and say the ship was not sunk - just to waste players move. 
%Fraud proof: Player can send all signed messages (i.e. bit reveals) - and if none of the messages %say "SUNK" (along all bits were hit!) - then it is evidence the counterparty cheated. This becomes obvious after the player has wasted 1-2 moves (i.e. hit A1,A2,A3,A4, but A1 and A3 are water!) 


\subsection{Modifying battleships to support state channels}

We modify both battleship contracts before deployment to support state channels. 
This requires explicitly stating the list of participants $\participant$ and the dispute timer $\timerdispute$ for use in the state channel.  
A new flag $\instantiated$ is set as $\instantiated := \instantiatedno$  and the pre-condition $\textsf{discard if } \instantiated  = \instantiatedyes$ is included in every function $\battleshipbegin, \battleshipgameover, \battleshipattackslot, \battleshiprevealslot, \battleshipsinking, \\ \battleshipfraud, \battleshiprevealboard$ and $\battleshiprevealships$. 
If the pre-condition is satisified, then the function is considered locked and the transaction automatically fails (i.e. an exception is thrown and all computation is reverted). 

The lock function $\applock$ requires a signature from every party to authorise creating the state channel. 
This increments a counter $k$ which tracks the number of times a state channel is turned on, the contract sets $\instantiated := \instantiatedyes$ to signal creating the state channel contract with $\participant$,$\timerdispute$ and finally the state channel's contract address is stored  $\statechannel$. 
On the other hand, the unlock function $\appunlock$ requires the dispute process to be complete in the state channel contract. 
Any party can submit the current state of the battleship game $\stateinfo$ (alongside the blinding nonce $r$) to $\appcontract$ and this is stored if it corresponds to the state hash $\hstate$ in the state channel contract. 
If successful, the flag $\instantiated$ is set as $\instantiatedno$ and all functionality is re-enabled in the battleship game. 


TODO: On the other hand, an off-chain version for either contract is required to allow the parties to execute the application amongst themselves. 
This off-chain version should disable/remove any functionality which has a side-effect on the blockchain (i.e. interaction with another contract).
In the case of the battleship contracts, only the auxillery functions $\battleshipdeposit$ and $\battleshipwithdraw$ are disabled. 

Simulate block height + absolute time.: Caution must be taken over timers too; i.e. if we rely on block height - this must be simulated in the off-chain environment. 

\section{Experiment on Ethereum's Test Network}

\section{Discussion} 

\paragraph{Channel vs Plasma} Validators = users, whereas validators != users. Both rely on a global blockchain as a root of trust. 

\paragraph{Private blockchain} All participants can execute a smart contract via a private blockchain (to simulate its execution), and sign the resulting state amongst themselves. After all, we only care for the normal execution of a smart contract. 

\paragraph{Dynamic Participation} Unlike Sprites/PISA, new parties cannot be added to this state channel. All parties would have to close/re-open the state channel. Although it is feasible to "combine" both constructions to support commands for adding parties to the channel, and then for the latest state. We leave this as future work for now. 

\paragraph{Go through top 100 contracts by volume, make sense in a channel?} 
\paragraph{Non-attributable problem} Fundamentally, it appears impossible to determine the cause behind a dispute on the blockchain. i.e. one party refuses to sign update; or A just doesnt send B's signature to blokchain and instead sends a previous state.

\paragraph{Funfair Dilemma} Should we optimise for minimal on-chain or off-chain state? Sprites/PISA/Funfair assume everything is on-chain (via single application) and Perun/L4 assume several contracts can live off-chain. 

This also raises the problem of splitting transaction fees. In a 2 party channel it is straight-forward (i.e. split half way), but in a n-party channel - the griefer can cause a multiplier of fee cost to everyone. Even worst as mentioned before - no evidence who the griefer is! 

\paragraph{Chicke and egg problem} Does the app contract create state channel? Or should the state channel create the application? Related to funfair dilemma - one assumes contract is already on-chain, other assumes it is created off-chain. 


\paragraph{Applications of state channels} All parties must remain on-line for the execution of a state channel. As a result, applications may be context-specific (i.e. quick auctions for buying/selling AdWords, but not for the Ethereum Name Service). 

\paragraph{Application Timers} There is support for both absolute and relative timers. Relative timers are ideal as they allow the designer to avoid considering the dispute process time (i.e. it starts ticking once the application is re-activated). However, absolute time locks are sometimes necessary/unavoidable (i.e. HTLC transfers). 

\paragraph{Benefit to PISA} All applications rely on a single state channel contract. Thus, a custodian only has to verify the bytecode for a single contract and can accept jobs for any application. 

\paragraph{Race conditions} What if two commands are proposed at the same time? No way to resolve that. Same problem with front-running and contracts. issues do not go away. Not problem for battle-ship, as the game dynamics are clearly defined as a force-move game. 

\paragraph{Limitations due to EVM/Solidity} Cannot delete a mapping - problems if channel is created half-way thru and app; and you update values in the mapping! need to keep an array of all key-values... could try to store all state in a single contract, delete/recreate contract; but that is expensive (similar to the dispute registry).  

\paragraph{Probablistic checking board's integrity} Impacts the UX/fun of the game. i.e. you need to have a randomly allocated board, ruins the fun. Could have a zkSNARK to prove integrity of the board. In fact, due to the commit, reveal and then explicit acknowledgement to begin the game - the game does not need to verify the zkSNARK (or any of the N boards validity). We leave this as future work.  

\paragraph{Attacks we cant solve} Griefing - every time we ask counterparty to reveal commitment - there has to be a fixed time period to do it - similar to real life - there is nothing we can do about it - and due to latency on the network - the game could be dragged out for hours. This provides a benefit to use something like Plasma - where the block latency can be super quick (and thus the counterparty has 5 minutes to reply, and not 1 hour). State channel cant get around this -by definition we always hit the worst case. 


 
\appendix

\section{Security Analysis for Battleship Game}


\begin{figure}[h]
	\begin{boxedminipage}{\columnwidth}
		\begin{center}
			\textsf{State channel contract}{}\\
		\end{center}
		
		$\chanstatus := \bot \\
		\participant  := \emptyset, \appcontract := \bot, \\ \hstate := \bot, \monotoniccounter := 0 \\ \timerdispute := 0, \timenow := 0, \timeend := 0$
		
		\begin{flushleft}
			\constructor($\participant', \timerdispute', \appcontract'$):
			
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{set} $\participant := \participant'$ \\
			\quad \textbf{set} $\timerdispute := \timerdispute'$ \\ 
			\quad \textbf{set} $\appcontract := \appcontract'$ \\
			\quad \textbf{set} $\chanstatus := \chanon$ \\
			
		\end{tabular}
		
		\begin{flushleft}
			\oninput \stringlitt{triggerdispute}($\sigma_{k}$): 
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\chanstatus \neq \chanon$ \\
			\quad \textbf{discard if} $\participant \notin \participant_{k}$ \\
			\quad \textbf{if} $\verifysig(\participant_{k}, (\statechannel, \appcontract, ``\mathsf{dispute}"), \sigma_{k})$ \\
			\quad \quad \textbf{set} $\chanstatus := \chandispute$ \\
			\quad \quad \textbf{set} $\timestart := \timenow$ \\
			\quad \quad \textbf{set} $\timedispute := \timestart + \timerdispute$
			
		\end{tabular}
		
		
		\begin{flushleft}
			\oninput  \stringlitt{setstatehash}($\hstate', \monotoniccounter', \Sigma_{\participant}$):
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\chanstatus = \chanoff$ \\
			\quad \textbf{discard if} $\monotoniccounter' \leq \monotoniccounter$ \\
			\quad \textbf{if} $\verifysig(\participant, (\hstate', \monotoniccounter', \statechannel, \appcontract), \Sigma_{\participant})$ \\
			\quad \quad \textbf{set} $\hstate := \hstate'$ \\
			\quad \quad \textbf{set} $\monotoniccounter := \monotoniccounter'$ \\
		\end{tabular}
		
		\begin{flushleft} 
			\oninput \stringlitt{resolve}(): 
		\end{flushleft}
		\begin{tabular}{l}
		\quad \textbf{discard if} $\chanstatus \neq \chandispute$ \\
		\quad \textbf{discard if} $\timenow < \timeend$ \\
		\quad \textbf{set} $\chanstatus := \chanoff$ 
		\end{tabular}
	
		\begin{flushleft} 
		\oninput \stringlitt{getstatehash}(): 
		\end{flushleft}
		\begin{tabular}{l}
		\quad \textbf{discard if} $\chanstatus \neq \chanoff$ \\
		\quad \textbf{return} $\hstatei$
		\end{tabular}
		
		\begin{flushleft} 
			\oninput \stringlitt{getdispute}(): 
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\chanstatus \neq \chanoff$ \\
			\quad \textbf{return} $(\timenow, \timeend, \monotoniccounter)$
		\end{tabular}
	\end{boxedminipage}
	\caption{The state channel contract. It is responsible for managing the dispute process and determining the final state hash.  Discard fails the transaction execution if the pre-condition is satisfied.} \label{fig:statechannel}
\end{figure}

\begin{figure}
\begin{boxedminipage}{\columnwidth}
	\begin{center}
		\textsf{Template for application contract}{}\\
	\end{center}
	
	$\instantiated := \bot,  \stateinfo := \bot \\ 
	\participant  := \emptyset,  \timerdispute := 0, \\
	\statechannel := \bot, \mathsf{k} := 0$
	
		
	\begin{flushleft}
		\constructor($\participant'$): 
	\end{flushleft}
	\begin{tabular}{l}
		\quad \textbf{set} $\participant := \participant'$ \\
		\quad \textbf{set} $\instantiated := \instantiatedno$ \\
		
	\end{tabular}

	\begin{flushleft}
		\oninput \stringlitt{example}(): 
	\end{flushleft}
	\begin{tabular}{l}
		\quad \textbf{discard if} $\instantiated = \instantiatedyes$ \\
		\quad \_;
		
	\end{tabular}
	
	
	\begin{flushleft}
		\oninput  \stringlitt{lock}($\timerdispute', \Sigma_{\participant}$):
	\end{flushleft}
	\begin{tabular}{l}
		\quad \textbf{discard if} $\instantiated = \instantiatedyes$ \\
		\quad \textbf{if} $\verifysig(\participant,(``\mathsf{instantiate}", \appcontract, \mathsf{k}),\Sigma_{\participant})$ \\
		\quad \quad \textbf{set} $\instantiated := \instantiatedyes$ \\
		\quad \quad \textbf{set} $\mathsf{k} := \mathsf{k} + 1$ \\
		\quad \quad \textbf{set} $\statechannel := \mathsf{StateChannel}(\participant, \timerdispute, \mathsf{this})$
	\end{tabular}
	
	\begin{flushleft} 
		\oninput \stringlitt{unlock}($\stateinfo',\ran'$): 
	\end{flushleft}
	\begin{tabular}{l}
		\quad \textbf{discard if} $\instantiated = \instantiatedno$ \\
		\quad \textbf{if} $\hash(\stateinfo', \ran') = \statechannelgetcommitment()$ \\
		\quad \quad $\instantiated := \instantiatedno$ \\
		\quad \quad $\stateinfo := \stateinfo'$ \\
		\quad \textbf{else if} $\bot = \statechannelgetcommitment()$  \\
		\quad \quad $\instantiated := \instantiatedno$
	\end{tabular}
\end{boxedminipage}

	\caption{The application contract template. The above modifications must be included to support a state channel. It allows all functionality to be disabled when the channel is created and re-enables all functionality after the dispute process when provided with the full state.}\label{fig:appmodify}
\end{figure}


\begin{figure}[h]
	\begin{boxedminipage}{\columnwidth}
		\begin{center}
			\textsf{BattleshipCon1}{}\\
		\end{center}
		
		$\instantiated := \bot, \statechannel := \bot,	\participant  := \emptyset \\ 
		 \timestart := 0, \timeend := 0,, \timerchallenge := 0, \timerdispute := 0$ \\
		$\textsf{struct ship} \{(i,j),(i',j'),k, r\}, \mathsf{ship}[6]$ \\
	    $\textsf{struct slot} \{b, r\}, \mathsf{slot}[10][10]$ \\
	    $\hslot[10][10], \hship[6]$ \\
		$\gamestatus := \gamesetup, \textsf{turn} := \bot$
		
		\begin{flushleft}
			\constructor($\participant', \timerdispute', \timerchallenge$):
			
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{set} $\participant := \participant'$ \\
			\quad \textbf{set} $\timerdispute := \timerdispute'$ \\ 
			\quad \textbf{set} $\timerdispute:= \timerchallenge$ \\ 
			
		\end{tabular}
		
		\begin{flushleft}
			\oninput \stringlitt{select}($\sigma_{\participant}, \hslot[10,10], k[6], \hship[6]$): 
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\instantiated = \instantiatedyes$ \\
			\quad \textbf{if} $\verifysig(\sigma_{\participant},\hslot[0,0],...,\hslot[10,10],(k[1],\hship[1]),...,(k[n],\hship[n]),\participant)$ \\
			
		\end{tabular}
		
		
		\begin{flushleft}
			\oninput  \stringlitt{begingame}($\hstate', \monotoniccounter', \Sigma_{\participant}$):
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\instantiated = \instantiatedyes$ \\
		\end{tabular}
		
		\begin{flushleft} 
			\oninput \stringlitt{resolve}(): 
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\chanstatus \neq \chandispute$ \\
			\quad \textbf{discard if} $\timenow < \timeend$ \\
			\quad \textbf{set} $\chanstatus := \chanoff$ 
		\end{tabular}
		
		\begin{flushleft} 
			\oninput \stringlitt{getstatehash}(): 
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\chanstatus \neq \chanoff$ \\
			\quad \textbf{return} $\hstatei$
		\end{tabular}
		
		\begin{flushleft} 
			\oninput \stringlitt{getdispute}(): 
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\chanstatus \neq \chanoff$ \\
			\quad \textbf{return} $(\timenow, \timeend, \monotoniccounter)$
		\end{tabular}
	\end{boxedminipage}
	\caption{The state channel contract. It is responsible for managing the dispute process and determining the final state hash.  Discard fails the transaction execution if the pre-condition is satisfied.} \label{fig:statechannel}
\end{figure}


\end{document}
