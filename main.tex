\PassOptionsToPackage{usenames}{xcolor}
\PassOptionsToPackage{dvipsnames}{xcolor}
\documentclass{llncs}
\usepackage[utf8]{inputenc}
\usepackage{booktabs} % For formal tables
\usepackage{multirow}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{url}
\usepackage{xspace}
\usepackage{pifont}% http://ctan.org/pkg/pifont
\usepackage{color}
\usepackage{boxedminipage}
\usepackage[ff,sets,keys,primitives,operators]{cryptocode}
\usepackage{framed}
\usepackage[group-separator={,}]{siunitx}
\newcommand\bmmax{2}
\usepackage{bm}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{footnote}
\usepackage{units}
\usepackage{multicol,lipsum}
\colorlet{iomsg}{MidnightBlue}
\colorlet{party}{brown}
\colorlet{entry}{NavyBlue}
\colorlet{string}{BlueViolet}

\newcommand{\instantiated}{\mathsf{instantiated}}
\newcommand{\instantiatedno}{\mathsf{NO}}
\newcommand{\instantiatedyes}{\mathsf{YES}}

\newcommand{\gamestatus}{\mathsf{phase}}
\newcommand{\gameregister}{\mathsf{INIT}}
\newcommand{\gamesetup}{\mathsf{SETUP}}
\newcommand{\gameattack}{\mathsf{ATTACK}}
\newcommand{\gamereveal}{\mathsf{REVEAL}}
\newcommand{\gamewinner}{\mathsf{WIN}}
\newcommand{\gamefraud}{\mathsf{FRAUD}}
\newcommand{\gamefinished}{\mathsf{GAMEOVER}}

\newcommand{\chanstatus}{\mathsf{status}}

\newcommand{\chanon}{\mathsf{ON}}
\newcommand{\chandispute}{\mathsf{DISPUTE}}
\newcommand{\chanoff}{\mathsf{OFF}}

\newcommand{\hready}{\mathsf{hready}}
\newcommand{\hboard}{\mathsf{hboard}}
\newcommand{\hslot}{\mathsf{hslot}}
\newcommand{\hship}{\mathsf{hship}}
\newcommand{\hshiplocation}{\mathsf{hshiplocation}}

%\newcommand{\hash}{\textsf{H}}
\newcommand{\cmd}{\mathsf{cmd}}
\newcommand{\hstate}{\mathsf{hstate}}
\newcommand{\hstatei}{\mathsf{hstate}_{\monotoniccounter}}
\newcommand{\hstateplus}{\ensuremath{\mathsf{hstate}_{\monotoniccounter+1}}}
\newcommand{\hstateminus}{\ensuremath{\mathsf{hstate}_{\monotoniccounter-1}}}
\newcommand{\monotoniccounter}{\mathsf{i}}
\newcommand{\stateinfo}{\mathsf{state}}
\newcommand{\stateinfoi}{\mathsf{state}_{\mathsf{i}}}
\newcommand{\stateinfominus}{\mathsf{state}_{\mathsf{i-1}}}
\newcommand{\stateinfoplus}{\mathsf{state}_{\mathsf{i+1}}}
\newcommand{\participant}{\mathcal{P}}

\newcommand{\rani}{\mathsf{r}_{\mathsf{i}}}
\newcommand{\ran}{\mathsf{r}}
\newcommand{\ranminus}{\mathsf{r}_{\mathsf{i-1}}}
\newcommand{\ranplus}{\mathsf{r}_{\mathsf{i+1}}}

\newcommand{\statechannel}{\mathsf{SC}}
\newcommand{\statechanneldispute}{\mathsf{SC}.\mathsf{trigger}}
\newcommand{\statechannelsetstate}{\mathsf{SC}.\mathsf{setstatehash}}
\newcommand{\statechannelresolve}{\mathsf{SC}.\mathsf{resolve}} 
\newcommand{\statechannelgetcommitment}{\mathsf{SC}.\mathsf{getstatehash}} 
\newcommand{\statechannelgetdispute}{\mathsf{SC}.\mathsf{getdispute}} 

\newcommand{\sign}{\mathsf{Sign}}
\newcommand{\verifysig}{\mathsf{VerifySig}}

\newcommand{\battleship}{\mathsf{BS}}
\newcommand{\battleshipfraud}{\mathsf{BS.fraud}}
\newcommand{\battleshipattackslot}{\mathsf{BS.attackslot}}
\newcommand{\battleshipbegin}{\mathsf{BS.begingame}}
\newcommand{\battleshipcommit}{\mathsf{BS.commit}}
\newcommand{\battleshipselectboard}{\mathsf{BS.select}}
\newcommand{\battleshiprevealslot}{\mathsf{BS.openslot}}
\newcommand{\battleshipsinking}{\mathsf{BS.sunk}}
\newcommand{\battleshiprevealships}{\mathsf{BS.winnerships}}
\newcommand{\battleshiprevealboard}{\mathsf{BS.winnerboard}}
\newcommand{\battleshipgameover}{\mathsf{BS.gameover}}
\newcommand{\battleshipdeposit}{\mathsf{BS.deposit}}
\newcommand{\battleshipwithdraw}{\mathsf{BS.withdraw}}

\newcommand{\battleshipadjacent}{\mathsf{BS.adjacentships}}
\newcommand{\battleshipnotstraightline}{\mathsf{BS.notstraightline}}
\newcommand{\battleshipshipnotplaced}{\mathsf{BS.shipnotplaced}}
\newcommand{\battleshipnotsunk}{\mathsf{BS.declarednotsunk}}
\newcommand{\battleshiplock}{\mathsf{BS.lock}}
\newcommand{\battleshipunlock}{\mathsf{BS.unlock}}
\newcommand{\battleshipgetstate}{\mathsf{BS.getstate}}

\newcommand{\appcontract}{\mathsf{AC}}
\newcommand{\applock}{\mathsf{AC.lock}}
\newcommand{\appunlock}{\mathsf{AC.unlock}}

\newcommand{\timerchallenge}{\mathsf{\Delta}_{\mathsf{challenge}}}
\newcommand{\timechallenge}{\mathsf{t}_{\mathsf{challenge}}}
\newcommand{\timerextra}{\mathsf{\Delta}_{\mathsf{extra}}}
\newcommand{\timerdispute}{\mathsf{\Delta}_{\mathsf{dispute}}}
\newcommand{\timenow}{\mathsf{t}_{\mathsf{now}}}
\newcommand{\timestart}{\mathsf{t}_{\mathsf{start}}}
\newcommand{\timeend}{\mathsf{t}_{\mathsf{end}}}
\newcommand{\timedispute}{\timenow + \mathsf{\Delta}_{\mathsf{dispute}}}

% Colorful diagrams 
\newcommand{\constructor}{\textcolor{entry}{\bf constructor }}
\newcommand{\oninput}{\textcolor{entry}{\bf function }}
\newcommand{\stringlitt}[1]{\texttt{\textcolor{string}{#1}}}

\begin{document}


	\title{An empirical evaluation of state channels as a scaling solution for cryptocurrencies}
	\maketitle
	\begin{abstract}
		So-called Layer 2 and Off-chain solutions are heralded as a scaling solution for cryptocurrencies. 
	\end{abstract} 

\section{Introduction}

We propose a new state channel construction that combines the dispute process model from Sprites to support $n$-parties, the ability to turn a channel on/off by requiring the dispute process to determine the latest state commitment from L4/PERUN and finally it incorporates state commitments from PISA such that the dispute process is only responsible for accepting the latest state commitment that was authorised by all parties. 


1. how much has the ethereum foundation invested?
2. how much has the ethereum community fund invested?
3. how many companies exist to have deployed state channels / currently in the works. 



\begin{itemize}
\item A new dispute process that supports any application and ensures quick liveness of the application (i.e. sprites, every command dispute = slow, L4/Perun requires incorporating channel into app)
\item Financial incentives + fraud proofs can be used to avoid elaborate cryptography to build meaningful applications. Can only go so far (i.e. makes sense for battleships as everything is eventually revealed, but not e-voting) 
\item The first empirical evaluation of state channels as a scaling solution. 

\end{itemize}
\section{Background}

In this section, we provide background information about Ethereum, smart contracts and how the concept of a channel has evolved. 

\subsection{Ethereum and smart contracts}


A smart contract is a state machine, where the state transition is executed on-chain based on an authorised command. 


\subsection{Evolution of channel constructions}

In Bitcoin - dispute process is to determine latest state and "close" the channel. Awkward to make this work - Lightning relies on revocation/penalty to enforce latest state is broadcast/accepted. 

In Perun/L4 - the dispute process is to determine the latest state and "close" the channel. 

In Sprites - dispute process is to process "commands" such as payments / withdrawals. Useful for single-purpose commands, not great for continuous applications (i.e. gaming) due to dispute process per command.

In Pisa - dispute process extends Sprites, but adds privacy-preserving feature - this allows state channel contract to be independent of the application. 

\section{State Channel Construction} 

%We propose a state channel contract and modifications to an application contract that is required to support the state channel.
We propose a new state channel contract $\statechannel$ and a template of modiciations for an application contract $\appcontract$  to support state channels. 
This modification provides a mechanism for locking (and unlocking) the application into a state channel upon approval of all parties. 

At a high level, the locking mechanism $\applock$ disables all functionality within the application contract and instantiates the state channel contract. 
Once locked, all parties execute the application off-chain amongst themselves by proposing  and co-operatively signing the hash of every new state alongside an incremented counter. 
A state hash is only considered valid when each party has received a signature from every other party. 
To turn off the channel, any party can trigger the dispute process using $\statechanneldispute$ via the state channel contract.
This provides  a fixed time period  for all parties to publish the state hash with the largest monotonic counter using $\statechannelsetstate$. 
After the dispute process has expired, any party can resolve the dispute using $\statechannelresolve$ which turns off the channel, confirms the state hash with the largest monotonic counter as the accepted state, and allows any party to unlock the application contract $\appunlock$. 
To unlock, any party can reveal the state (in plain text) to the application contract and this opening is verified by fetching the final state hash from the state channel contract using  $\statechannelgetcommitment$. 
Once verified, the full state is stored within the application contract and all functionality is re-enabled to permit execution to continue on-chain. 

In the following, we present the new state channel contract and the modifications required to an application contract. 


\subsection{State channel contract}

%\paddy{I'd like to add "commands" into the state channel; so we can add/remove new participants (or withdraw coins) without turning off the channel. Basic SPRITES construction! }

%The state channel contract manages the dispute process and it is responsible for determining the state commitment that is used by the application contract before its functionality is re-enabled to permit on-chain state transitions. 
We provide an overview of the state channel construction before discussing how to set it up, how participants authorise state transitions off-chain and how the dispute process confirms the final state hash. 

\paragraph{Overview of the state channel contract} 
Figure \ref{fig:statechannel} presents an overview of the state channel contract. 
It contains a list of parties $\participant_{1},...,\participant_{n}$, a dispute timer $\timerdispute$, the application contract's address $\appcontract$ and a  $\chanstatus = \{\chanon, \chandispute, \chanoff\}.$

Upon creation, the contract is set as $\chanstatus := \chanon$ and all parties can collectively execute the application by signing every new state hash (and an incremented nonce).
This is denoted as $\sigma_{\participant} := \sign_{\participant}(\hstatei, \monotoniccounter)$, where  $\hstatei = \hash(\stateinfoi, \rani)$ is the state hash ($\ran$ is a nonce) and $\monotoniccounter$ is an incremented monotonic counter. 
A state hash is only considered valid when each party has a signature from every other party. 
If one party aborts and does not sign the state hash, then any party can turn off the channel by triggering a dispute using $\statechanneldispute$ which sets $\chanstatus := \chandispute$. 

This provides a fixed time period between $\timenow$ and $\timedispute$ for all parties to respond using $\statechannelsetstate$ with $\hstate$, its monotonic counter $\monotoniccounter$ and a corresponding signature from every party $\Sigma_{\participant}$. 
Afterwards, any party can resolve the dispute using $\statechannelresolve$ which sets $\chanstatus := \chanoff$ and allows the final $\hstatei$ to be fetched by $\appcontract$ using  $\statechannelgetcommitment$. 
Finally the dispute time period and the final counter is recorded which can later be fetched using $\statechannelgetdispute$. 
%
%
%This command alongside a commitment to the new state and 
%This command alongside a signed state commitment tuple $(\hstateplus,\monotoniccounter+1)$ is sent to the other parties.
%To verify, each party computes the new $\stateinfoplus$ (and its corresponding counter) using the received $\cmd$ before exchanging their signature for the new state commitment. 
%A state commitment is not considered authorised until every party has a signature from every other party in the channel. 
%If one party aborts and does not sign the state commitment, then any party can trigger the dispute process in the state channel. 
%This provides a fixed time period for all parties to submit the latest authorised commitment $h_{i+1}$ alongside a list of signatures $\sigma_{p1},...,\sigma_{pn}$ to the state channel contract.
%Once the dispute process has expired, the commitment $h_{n}$ with the largest monotonic counter is considered the final state and it becomes available for the application contract to fetch. 

\paragraph{Creating the channel} 

The application contract $\appcontract$ is responsible for instantiating the state channel contract and providing it with the list of participants $\participant_{1},...,\participant_{n}$, the dispute timer $\timerdispute$, the address $\appcontract$ and setting $\chanstatus := \chanon$. 
As we discuss in the next section, all functionality in the application contract is disabled after the state channel contract is created. 

\paragraph{Authorising off-chain state hashes}
A command $\cmd$ is a function call within the application contract.
Any party can select a command $\cmd$ and propose a new state transition $\stateinfoplus := \mathsf{transition}(\stateinfoi, \cmd)$.
The new state is hashed  $\hstateplus = \hash(\stateinfoplus, \ranplus)$ and signed  $\sigma_{\participant} := \sign(\hstateplus,\monotoniccounter+1)$.
To finalise the state transition, the proposer sends $\cmd,\hstateplus, \stateinfoplus, \ranplus$ to all other parties for their approval.

All other parties in the channel verify the state transition before authorising it. 
To verify, each party re-computes the state transition $\stateinfoplus' := \mathsf{transition}(\stateinfoi, \cmd)$ and the state hash $\hstateplus' := \hash(\stateinfoplus', \ranplus)$.
Then, each party verifies the received signature $\verifysig(\participant, (\hstateplus', \monotoniccounter+1), \sigma_{\participant})$ and that the counter is the largest received so far. 
If satisfied, each party signs the state hash  $\sigma_{k} := \sign(\hstateplus,\monotoniccounter+1, \statechannel, \appcontract)$ and sends their signature alongside the state information $\cmd,\hstateplus, \stateinfoplus, \ranplus, \sigma_{k}$ to all other parties. 

The new state hash is only considered valid when each party has received a signature from every other party.  If one party does not receive all signatures within a local time-out, then this party can trigger the dispute process to turn off the channel and continue the application's execution on-chain. 

\paragraph{Dispute process.} 

Any party can trigger the dispute process using $\statechanneldispute$ which self-enforces a time period $\timestart := \timenow$, $\timeend := \timedispute$ and sets $\chanstatus = \chandispute$. 
Any party can submit the latest state hash (alongside a signature from every party $\Sigma_{\participant})$ during the dispute period using $\statechannelsetstate$. 
The state channel contract $\statechannel$ only stores the $\hstatei$ if it is  signed by all parties within the state channel and it is  associated with the largest $\monotoniccounter$ received so far. 
After the dispute period has expired, any party can resolve it using $\statechannelresolve$ which sets $\chanstatus = \chanoff$, stores a dispute record ($\timestart,\timeend, \monotoniccounter$) and allows the application contract $\appcontract$ to fetch the final state hash $\hstatei$. 

\subsection{Application Contract}

We propose a state channel template to modify an application contract. 
The template disables all functionality in $\appcontract$  after instantiating the state channel and re-enables the application to support continuous on-chain execution after turning off the state channel. 
In the following, we provide an overview of the template before discussing the locking and unlocking mechanism. 


\paragraph{Overview of template. } \label{sec:template} 
Figure \ref{fig:appmodify} presents an overview of the application contract template.
After modifications, the application contract must explicitly record a list of participants $\participant_{1},...,\participant_{n}$, a dispute timer $\timerdispute$, whether the state channel has been instantiated  $\instantiated := \{\instantiatedyes, \instantiatedno\}$ and if so it also stores the state channel's address  $\statechannel$. 
All functions within the application require a new pre-condition to check whether the state channel is instantiated and should only permit execution if $\instantiated = \instantiatedno$. 
Finally the application must include two new functions $\applock$ that instantiates the state channel upon approval of all parties and $\appunlock$ that verifies a copy of the full state before re-enabling the application. 


%A dispute time period 
%An explicit list of participants 
%A new boolean (on/off) and a pre-condition for every function in the contract (i.e. only allow function to be used if state channel is off)
%Two new functions: create channel (requires a signature from all parties) and setstate (receive full state, fetch hash, compare, store on-chain and re-enable functionality). 


 
\paragraph{Lock application contract} All parties must approve to instantiating the state channel by signing $(\chanon, \appcontract, \timerdispute, \mathsf{k}$), where $\chanon$ signals turning on the channel, $\mathsf{k}$ is an incremented counter to ensure freshness of the signed message and $\timerdispute$ is the fixed time period for the dispute process. 
Any party can call $\applock$ with the list of signatures $\Sigma_{\participant}$, $\timerdispute$ and $\mathsf{k}$ to turn on the state channel. 
The application contract $\appcontract$ verifies all signatures and that $\mathsf{k}$ represents the largest counter received so far.
If satisfied, $\appcontract$ sets  $\instantiated := \instantiatedyes$ effectively disables all functionality within the application.
Next $\appcontract$ creates the state channel contract $\statechannel$ which sets the list of participants $\participant_{1},...,\participant_{n}$ and the dispute timer $\timerdispute$. 
Finally $\appcontract$ stores the state channel address $\statechannel$. 
 

\paragraph{Unlock application contract}

After the dispute process has concluded in $\statechannel$, one party must send  $\stateinfoi',\rani'$ using $\appunlock$ before the functionality can be re-enabled.
The application contract verifies that $\stateinfoi'$  indeed represents the final state by computing $\hstatei' := \hash(\stateinfoi', \rani')$, fetching the final state hash $\hstatei$ from $\statechannel$ using $\statechannelgetcommitment$ and checking  $\hstatei' = \hstatei$. 
If satisfied, $\appcontract$ stores $\stateinfoi'$ and re-enables all functionality by setting $\instantiated :=  \instantiatedno$. 
Of course, if there is no activity within the state channel, then the state channel contract's dispute process can expiry without a submitted $\hstatei$.
In this case, the application contract verifies the state channel returns $\emptyset$ and re-enables all functionality without modifying the existing state. 


%Notes: While all functionality is disabled on-chain; we need to be careful with how parties execute it off-chain! Not all functionality can be supported off-chain (i.e. contract to contract interaction); so this needs to be considered. 

\section{Battleship within a State Channel} 

%In this section, we propose tow contracts for the game battleship and demonstrate how it can be adopted to support state channels. 
%One battleship game relies on a commitment to every slot in the grid and every ships, while the other battleship game simply has a commitment to every ship. 
%We highlight that our game relies on financial incentives and fraud proofs to self-enforce its integrity as opposed to extensive cryptography.
We provide a high-level overview of the game battleship before proposing how to implement it as a smart contract.  
In our proposed protocol, we demonstrate how to overcome the computational limitation of checking the validity of a player's board using fraud proofs via a challenge-response protocol. 
Afterwards we present how to convert the battleship game to support state channels using the template in Section $\ref{sec:template}$. 
%To play the game requires both parties to commit to a list of ships 
%To overcome the computational limitation of checking the validity of a battleship game, we demonstrate how to use fraud proofs 
%The first contract requires a commitment to every slot in a player's board alongside a list of ship commitments, whereas the second game only relies on a list of ship commitments. 
%Afterwards we discuss how to overcome the computational limitation of checking a full board's validity by relying on a challenge-response protocol. 
%This provides a fixed time period for a player to submit a proof of fraud that the counterparty's board is invalid.
%If the fraud proof is correct (and accepted), then the contract atomically forfeits the counterparty's deposit. 
%Finally we present how to convert both contracts to support state channels using the template in Section \ref{sec:template}. 
%We propose two contracts for the battleship game where one game has a commitment to every slot in the grid $\hslot_{i,j}$ and every ship $\hship_{1},...,\hship_{n}$, where the second game simply has the list of ship commitments. 
%Afterwards, we present the fraud proofs which are compatible with both contracts and how to convert them to support state channels. 

\subsection{Overview of Battleship}

Battleship is a two-player game where each player has a list of ships that are placed on a 10x10 private board. 
Each ship must be marked in a straight line either horizontally or vertically, and ships cannot be placed adjacent to each other.\footnote{Ships must be surrounded by water if there is available space on the board.}.
To minimise long-term storage (and the associated significant gas cost), our contract only relies on a commitment to every player's ship and signed messages exchanged between both parties. 

To set up the game, both parties participate in a cut-and-choose protocol.
Each player commits to $N$ lists of ships using $\battleshipcommit$. 
The counterparty selects one list of ships for the player using $\battleshipselectboard$.
Once selected, each player reveals the remaining $N-1$ list of ships to the counterparty. 
If both parties are satisified that all revealed ships are well-formed, they can signal to begin the game using $\battleshipbegin$, otherwise they may chose to quit using $\battleshipgameover$. 
%In the first contract, each player commits to $N$ boards using $\battleshipcommit$, whereas in the second contract each player simply commits to $N$ lists of ships. 
%Next, the counterparty selects a single board (or a single list of ships) using $\battleshipselectboard$. 
%Then, each player reveals all non-selected boards and list of ships to counterparty and this provides them an opportunity to verify all boards (and list of ships) are well-formed. 
%If each player is satisified, then they signal their desire to begin the game using $\battleshipbegin$ 
%Once the game is set up, both players take turns at shooting the other player's board.
In each turn, the player selects a slot to shoot using $\battleshipattackslot$ and the counterparty must open the slot  within a fixed challenge time period. 
To open, the counterparty reveals if the slot is occupied by water or a ship piece using $\battleshiprevealslot$.
If this shot sinks a full ship, then the counterparty must instead reveal the full ship alongside the slot's opening using $\battleshipsinking$. 
Of course, the player is provided another turn if their shot was successful.
%Throughout the game, the loser may have an opportunity submit a proof of fraud using $\battleshipfraud$ if it is detectable the counterparty's board (or list of ships) is invalid. 

At the end, the winner must reveal their board and every ship's location to the loser using $\battleshiprevealboard$.
The loser has a fixed time period to prove if the winner's board was incorrectly set up using $\battleshipfraud$, otherwise either player can call $\battleshipgameover$ after this fixed time period to finish the game. 

\subsection{Battleship Contract} 

We present each phase of the game, how to establish the contract, the cut-and-choose protocol to begin the game, the turn-based gameplay and finally how the loser is provided an opportunity to prove the winner cheated and thus should not be sent the winnings. 

\paragraph{Game Phases} There are six phases $\gamesetup, \gameattack, \gamereveal,  \gamewinner, \gamefraud, \\ \gamefinished$. 
The $\gamesetup$ phase is responsible for ensuring both players select a single list of ships before agreeing to begin the game. 
Game play transitions between $\gameattack$ and $\gamereveal$ as both players take a turn at shooting the counterparty's ships. 
The game transitions to $\gamewinner$ when one player wins the game and it will transition to $\gamefraud$ once the winner has opened all ship locations.
This provides the loser a fixed time period to submit a proof of fraud that the winner's board is not well-formed or that the winner did not honestly reveal a slot during the game. 
Otherwise, the contract transitions to $\gamefinished$ that allows the winner to claim their winnings and reset the contract. 
% to open  to declare a slot, otherwise the contract transitions to $\gamefinished$. 
%Of course, the contract transitions to $\gamefraud$ if a proof of fraud to detect cheating by the counterparty is provided and we explore this phase further in Section \ref{sec:fraud}. 

\paragraph{Contract establishment} 
The contract is established with the address of both players $\participant_{1},\participant_{2}$ and the challenge timer $\timerchallenge$. 
Both parties can deposit coins during $\gamesetup$ phase before placing their bets.

\paragraph{Prepare list of ships} Both parties participate in a cut-and-choose protocol during $\gamestatus := \gamesetup$. 
Each ship is the tuple $(k,\hship)$, where $k$ is the ship's length and $\hship := \hash(i,j,i\pm,j\pm,r, \mathsf{round}, \participant, \appcontract)$.
Each party computes and signs $N$ list of ships: 

\begin{center}
 $\Sigma_{1}^{N} := \sign_{\participant}(((k_{i,1},\hship_{i,1}),...,(k_{i,n},\hship_{i,n})), \participant, \mathsf{round}, \appcontract)$ 
\end{center}
 
This is sent to the counterparty who is responsible for selecting one list and reserving it for the game by submitting it alongside the corresponding signature using $\battleshipselectboard$. 
The party must open the remaining $N-1$ list of ships to the counterparty which provides an opportunity to check their validity. 
If satisified, each party notifies the contract to begin the game using $\battleshipbegin$ which is an explicit acknowledgement that each party has reviewed all opened list of ships.
If the counter-party does not open any ship lists, then the party can signal their desire to quit  using $\battleshipgameover$.
Finally the game $\mathsf{round}$ is incremented regardless if it continues or not. 

\paragraph{Game-play} \label{sec:gameplayships}
%The game phase transitions several times between $\gameattack$ and $\gamereveal$ as each player has a turn at shooting the counterparty's ships. 
The contract maintains a counter $\mathsf{move}$ which increments after each player has taken their turn. 
In the $\gameattack$ phase, the player challenges the counterparty to open a slot $i,j$ by signing: 

\begin{center}
	$\sigma^{shot}_{\participant} := \sign_{\participant}(i,j, \mathsf{move}, \mathsf{round},\appcontract)$ \\
\end{center}

This message is submitted using $\battleshipattackslot$ which transitions the game phase to $\gamereveal$ and sets a fixed time period $\timechallenge := \timenow + \timerchallenge$ for the counterparty's response. 
The counterparty signs one of two messages depending on whether a ship was sunk:

\begin{center}
	$\sigma^{hit}_{\participant} := \sign_{\participant}(i,j,b,\mathsf{move}, \mathsf{round},\appcontract)$ \\ $\sigma^{sunk}_{\participant} := \sign_{\participant}(i,j,i\pm,j\pm,r,\hship,\mathsf{move}, \mathsf{round},\appcontract)$
\end{center}

The counterparty is responsible for submitting either signed message. 
The first message states if the slot is marked with water $b=0$ or a ship location $b=1$.
It is submitted using $\battleshiprevealslot$.
The second message declares the shot sank a ship and requires the counterparty to open the corresponding ship commitment $\hship$ to $\battleshipsinking$. 
Each party must keep a copy of every signed message\footnote{Every signed message is emitted by the contract and thus it is easily fetchable.} as this can later be used as a proof of fraud as discussed in Section \ref{sec:fraud}.
The game transitions to $\gamewinner$ if one player has declared all their ships sunk. 

\paragraph{End of game} 

The winner opens the remaining ship commitments using $\battleshiprevealships$.
A fixed time period is enforced to permit time for the loser to submit a proof of fraud using $\battleshipfraud$.
After this time period, the winner can redeem their reward using $\battleshipgameover$ which also transitions the game phase to $\gamefinished$. 
%,(i,j)$  
%the signed message $\sign_{\participant}((b, r), (i, j), \instantiatedno, \appcontract)$.

%$\sign_{\participant}((b, r), (i, j), \instantiatedyes, $ $(r_{1},...,r_{k}), \appcontract)$, where $r_{1},...,r_{k}$ are the nonces required to open $\hshiplocation_{1},...,$ $\hshiplocation_{k}$. 

\subsection{Proof of Fraud} \label{sec:fraud}


The contract can self-enforce the game's integrity and verify if the counterparty has cheated during the game.
However fully validating the entire game requires significant computational resources and if this were performed within the contract then it would incur unreasonable transaction fees. 
Therefore the contract also relies on the loser checking for fraud and submitting proof if the counterparty has cheated. 
If the proof is submitted during the game, then the prover is set as the winner and the contract transitions to $\gamefraud$ which provides time to ensure both players have not cheated. 
If the proof is submitted by the loser during $\gamewinner$, then the contract transitions to $\gamefinished$ and the loser is sent the winnings.
In the following we highlight the fraud proofs that can be verified by the contract. 


\paragraph{Exceeded maximum number of moves} 
The contract maintains a counter $\mathsf{move}$ to keep track of the shots taken by both players. 
If $\mathsf{move}$ exceeds the number of cells available on the board, then the contract can confirm that both players have cheated.
This is the case as an honest player will have declared all their ships as sunk after every cell on their board has been opened.
Thus the game should have transitioned to $\gamewinner$ before it exceeds $\mathsf{move}$ and instead it will transition to $\gamefinished$ with no player set as the winner. 

\paragraph{Valid slot} 
The contract checks if the slot $i,j$ is within the permitted range $0,0,...,10,10$ for any signed message received. 

\paragraph{Player has shot the same slot twice} 
The contract does not store the opening of slots and thus it cannot independently verify if a player has shot the same slot twice.
The player must sign every slot opening and the counterparty can provide the contract with two signed messages $\sigma^{shot}_{\participant},\sigma^{shot'}_{\participant}$, the corresponding $\mathsf{move},\mathsf{move}'$ counters and the slot $i,j$. 
The contract verifies the player signed both openings, that the openings are for the same slot, and $\mathsf{move}\neq\mathsf{move}'$. 
This proof of fraud can be submitted to the contract at any point during the game. 

\paragraph{Counterparty was dishonest about a slot opening}
The counterparty has marked a slot $(i,j)$ as water, but an opened $\hship$ states it is a ship location. 
%As previously mentioned, the contract only stores ship openings and the player is required to store every signed slot opening. 
To prove fraud, the player submits the ship idenfitier $\hship$, the disputed slot location $i,j$ and the signed opening of the slot $\sigma^{hit}_{\participant}$. 
The contract can verify if this slot opening was signed by the counterparty as $b = 0$ and the ship $\hship$ claims to be at $i,j$.   
On the other hand, the counterparty may also mark a slot as a ship location,  but no ships are at that location.
This proof of fraud is similar as the player submits the disputed slot location $i,j$ alongside its signed opening $\sigma^{hit}_{\participant}$.
The contract is satisified if it cannot find a ship that claims to be at that location. 

%\paragraph{Adjacent ships} 
%This fraud proof proves that a ship is not surrounded by water and instead two ships are adjacent to each other (or claim to be at the same location on the board). 
%We only require the ship commitments $\hship_{1},\hship_{2}$ to be opened and the same proof can be used in both contracts. 
%Any party can submit the location $i,j$ for the first ship and $i',j'$ for the second ship.  
%The contract can verify if ships are adjacent by checking whether $i,j$ is within the range $i'\pm1, j'\pm1$ or if they claim to be at the same location $i,j = i',j'$.

\paragraph{A ship was not placed  horizontally or vertically}
The contract can check whether an opened ship was placed on the board horizontally or vertically. 
To verify, it checks that every location for a ship either has the same $i$ or $j$ co-ordinate, and that $i$ or $j$ is incremented (or decremented) strictly by one for every ship location. 
Finally it also checks the ship's length which is pre-determined by the contract

\paragraph{Two ships claim to be at  the same cell} 
This proof is applicable after both ships are opened and stored in the contract. 
The index for both ships and the slot $i,j$ is sent to the contract.
This allows the contract to look up the co-ordinates for each ship and check if it claims to be at location $i,j$. 

\paragraph{Ship was not declared as sunk}
The counterparty was dishonest and did not declare a ship as sunk. 
This proof is applicable during $\gamefraud$ after all ships are opened by the winner. 
All signed slot openings $\sigma^{hit}_{\participant,1},...,\sigma^{hit}_{\participant,k}$ and the ship identifier $\hship$ must be submitted to the contract.
This allows the contract to verify that every ship location was opened which implies the counterparty did not declare the ship as sunk (i.e. the final opening of a ship location should be $\sigma^{sunk}_{\participant}$). 

\paragraph{Challenge period has expired }
The contract relies on a global clock (i.e. block timestamp or block height) to set a fixed time period $\timerchallenge$ for a player to perform an action (i.e. take a shot, open a slot, open all ships, etc). 
If a player does not respond within this time period, then the counterparty can notify the contract to check if the challenge period has expired. 

\subsection{Modifications for a State Channel}

We present how to modify the battleship contract before deployment in order to support state channels.
This includes allocating information to be used in the state channel, attaching a new pre-condition to every function in the battleship game, the lock/unlock functionality to instantiate the state channel, and finally a new off-chain contract for verifying every state transition in the channel. 

\paragraph{Applying the application template}
The purpose of our application template outlined in Section \ref{sec:template} is to allocate information for the state channel.
When creating the contract, we set $\instantiated := \instantiatedno$ and store the dispute timer $\timerdispute$.
Both players $\participant_{1},\participant_{2}$ are set for use by the state channel if it is instantiated and the battleship contract maintains (and increments) a counter $\mathsf{chan}_{\mathsf{ctr}}$ to track the number of times this state channel is turned on. 
A new pre-condition $\textbf{discard if}$ $ \instantiated  = \instantiatedyes$ is included in every function\footnote{It is included in $\battleshipbegin, \battleshipgameover, \battleshipattackslot, \battleshiprevealslot, \battleshipsinking, \\ \battleshipfraud, \battleshiprevealboard$ and $\battleshiprevealships$. } and the transaction fails\footnote{A failed transaction reverts all computation and thus does not modify the state of any contract.} if the pre-condition is satisified.
This effectively disables all functionality within the application contract if it is locked and the state channel is turned on. 

\paragraph{Lock and unlock functions} 
The lock function $\battleshipunlock$ requires a signature from each party $\participant_{1},\participant_{2}$ to authorise creating the state channel: 

\begin{center}
	$\sigma^{lock}_{\participant} := \sign_{\participant}(''\mathsf{lock}", \mathsf{chan}_{\mathsf{ctr}}, \mathsf{round}, \battleship)$ 
\end{center}
Once the state channel is turned on, the battleship contract sets $\instantiated := \instantiatedyes$ to signal creating the state channel contract and finally it creates a new state channel contract $\statechannel$ with the list of participants $\participant_{1},\participant_{2}$ and the dispute timer $\timerdispute$. 
On the other hand, the unlock function $\appunlock$ requires the dispute process to be finished in the state channel contract. 
Any party can submit the final game $\stateinfo$ (alongside the nonce $r$).
The battleship contract verifies if it corresponds to the final state hash accepted by the state channel contract using $H(\stateinfo,r)$ == $\statechannelgetcommitment$.
If successful, the full state is stored and the flag $\instantiated$ is set as $\instantiatedno$ which effectively re-enables all functionality in the battleship contract. 

\paragraph{Handling Challenge Timer}\label{sec:timers}
The contract is no longer responsible for deciding or self-enforcing the time $\timechallenge$ on behalf of both parties and we propose two approaches to overcome this issue. 
The time $\timechallenge$ can be set by the player proposing a new state and the counterparty must verify the proposed time is within a range (i.e. a few minutes, or $k$ blocks) before mutually authorising to the new state.
It must also take into account the time it takes to turn off the channel via the dispute process $\timedispute$ and extra time to initiate/settle the dispute $\timerextra$. 
An alternative approach is to use a relative timer such that $\timechallenge$ is not updated by the players within the state channel.
Instead the time $\timechallenge$ is set by the contract once it is re-activated in the blockchain using $\battleshipunlock$ and if the game is in a relevant phase.

\paragraph{Off-chain Contract} 
We propose each player can deploy an \textit{off-chain contract} to a local blockchain in order to replicate execution of all state transitions. 
Any functions with \textit{side effects} (i.e. interact with other contracts or accounts) must be disabled as it is not guranteed that any side-effects will persist when the channel is closed. 
In the case of our battleship contract, we must disable the auxillery functions $\battleshipdeposit$ and $\battleshipwithdraw$ as they send/receive coins from other accounts/contracts. 
To disable, both functions can simply be removed from the off-chain version of the contract. 
Additionally, the off-chain contract can include a new $\battleshipgetstate$ to return the full state and the corresponding state hash $\hstate$ for signing. 

\section{Experiment on Ethereum's Test Network}

We present a proof of concept implementation of both the battleship game and the state channel as smart contracts in Ethereum. 
We provde a high level overview of the experiment set up, the gas cost of playing the battleship game on-chain, the additional gas cost of modifying the game to support state channels, the gas cost of creating / closing the state channel and finally the off-chain contract for verifying state transitions in the state channel. 

\paragraph{Experiment setup} 

What computers did we use? Was a central server involved for co-ordination? What did we use to simulate contract execution? Did we use private/test/main net? 

\paragraph{On-chain battleship game game} 

How much does it cost to run the full battleshop game on-chain? Without a state chanel? 

\paragraph{Modifications to support a state channel} 

How much does it cost for the new state channel? How much does it cost to include the new functionality + variables? How much does it cost to submit and store a "full state" to the blockchain?  

\paragraph{The state channel and its dispute process } 

How much does it cost for the new state channel? How much does it cost to include the new functionality + variables? How much does it cost to submit and store a "full state" to the blockchain?  

\paragraph{The off-chain contract for verifying state transitions} 

Local instance of contract. Execute it, sign and exchange messages. What is the round trip overhead? What error range did we use for timers? (i.e. within 1-2 minutes). 

\section{Discussion} 

\paragraph{Probablistic checking board's integrity} Impacts the UX/fun of the game. i.e. you need to have a randomly allocated board, ruins the fun. Could have a zkSNARK to prove integrity of the board. In fact, due to the commit, reveal and then explicit acknowledgement to begin the game - the game does not need to verify the zkSNARK (or any of the N boards validity). We leave this as future work.  


\paragraph{Worst-case scenario for state channels} 
One party can turn off the channel using the dispute process after all parties agree to execute the application off-chain.   
This is problematic as all parties are now committed to executing the entire application via the blockchain.
In the case of battleship, both parties commit to the battleship game using $\battleshipbegin$ and afterwards must play the entire turn-based game via the blockchain. 
Each player may have to publish up to 200 transactions (i.e. 100 attack slots, 100 open slots) to finish the game play which incurs significant transaction fees and may require a prolonged period of time to complete. 
Thus state channels must be strictly viewed as an optimistic scaling solution only if all parties are trusted to co-operate.  
%Our battleship game highlights the worst-case sc

%Griefing - every time we ask counterpartyto reveal commitment - there has to be a fixed time period to do it - similar to real life - there is nothing we can do about it - and due to latency on the network - the game could be dragged out for hours. This provides a benefit to use something like Plasma - where the block latency can be super quick (and thus the counterparty has 5 minutes to reply, and not 1 hour). State channel cant get around this -by definition we always hit the worst case. 

\paragraph{Incorporating command issuance} 
The state channel construction in Sprites allows parties to update the application contract's state without closing the channel.
Any party can update the state channel contract with the latest state and the dispute process is used to receive a command from each party.
After the dispute process has expired, the state transition is performed on-chain as each command is executed in the application contract and this results in a new state for use in the channel. 
This approach allows the state channel to support functionality with side-effects such as depositing/withdrawing coins or interacting with other contracts.
However it also requires the application contract to include a new $\mathsf{AC.transition}$ function that can evaluate the submitted commands.
While it appears compatible with our state channel construction, we have left it as future work to incorporate. 

%\paragraph{Non-attributable problem} 
%As previously mentioned in [towards bitcoin payments]
%Fundamentally, it appears impossible to determine the cause behind a dispute on the blockchain. i.e. one party refuses to sign update; or A just doesnt send B's signature to blokchain and instead sends a previous state.

\paragraph{Funfair dilemma} 
Perun and Counterfactual aim to minimise on-chain state (i.e. a single multi-signature contract) and allow two parties to create/destory multiple applications within a state channel. 
On the other hand, Funfair aims to maximimise on-chain state for a single application. 
Both approaches have an underlying assumption about the likelihood that one party may trigger a dispute and the financial cost of resolving this dispute by sending the full state to the blockchain.
We highlight that state channels introduce new economic attack vectors that must be considered when designing compatible applications.
In fact, this dilemma can be summed up in a single question:

\begin{center}
\textit{Will a player turn off the channel for a \$10 bet if it costs \$100 to complete the dispute process, re-activate the contract and win the bet via the blockchain?} 
\end{center} 

To answer the above question, our empirical evaluation confirms that based on the current state of the Ethereum network, the Funfair is preferable as it minimises the cost of the dispute process. 
This is crucial to reduce the impact of economic attacks to undermine the safety guarantee provided by state channels. We need experiment results to back this up with numbers. 

\paragraph{Application timers} 
As we mentioned in Section \ref{sec:timers}, there is no global clock available for setting time within a state channel as the contract no longer sets $\timechallenge$ on behalf of both parties.
We proposed two approaches where each player updates the time when proposing a new state or the time can be updated after the application contract is re-activated on the blockchain (and the state channel is turned off).  
For the first approach, we observed it requires minimal modification as the timer $\timerchallenge$ is modified to be $\timerchallenge + \timerdispute + \timerextra$ when the state channel is created.
However it also implies players must be cautious to close the channel with sufficient time to complete their move via the blockchain.
On the other hand, while the second approach protects both parties from the time it takes to re-activative the contract, it requires the appplication to be aware that the state channel is turned off and accordingly set the time $\timechallenge$ if the game is in a particular state (i.e. attack). 

\paragraph{Supporting arbitration outsourcing of state channels} 
To alleivate the securiy assumption that all parties must remain online and synchronised with the blockchain to watch for malice disputes, PISA proposed that parties can hire an accountable third party to watch the channel on their behalf. 
Our construction is beneficial to PISA as the state channel contract is independent of the customer's application. 
The accountable third party only requires a signature from every party in the channel $\Sigma_{\participant}$, the state hash $\hstate$ and the monotonic counter $\monotoniccounter$ to resolve disputes on the customer's behalf. 
Additionally,  the accountable third party is only required to verify the bytecode for the state channel contract before accepting a job from the customer. 

\paragraph{Persistent race conditions} 
The gameplay for battleship is turn-based and it is clear which player is responsible for proposing every new state. 
Setting up the game using $\battleshipcommit$ or $\battleshipbegin$ has no order and both players can propose a state transition for the same monotonic counter $i$. 
In this case, both players can use a deterministic rule to resolve the race condition (i.e. $\participant_{1}$ proposed state has priority) as the order of execution has no impact on the game's outcome. 
This highlights that race conditions in the underlying application are also reflected in the state channel and the state channel may be turned off if the order of execution has an impact on the application's outcome.

\paragraph{Limitations due to EVM/Solidity} Cannot delete a mapping - problems if channel is created half-way thru and app; and you update values in the mapping! need to keep an array of all key-values... could try to store all state in a single contract, delete/recreate contract; but that is expensive (similar to the dispute registry).  


\paragraph{Applications of state channels} All parties must remain on-line for the execution of a state channel. As a result, applications may be context-specific (i.e. quick auctions for buying/selling AdWords, but not for the Ethereum Name Service). 

\appendix

\section{Commitment to entire board}

One issue with our battleship game is that a player can lie about the opening of their slot. While they can never win the game by doing so; it does allow the player to require the counterparty to potentially shoot every slot on their board. One way to prevent this attack is to require the counterparty to commit to every slot on their board in advance of the game; and have it revealed throughout. The problem is that this requires a merkle tree verification per move or every hash (200) to be stored in the contract directly - thus increasing the game cost in the honest case. 


\paragraph{Representing the board}

A cell is represented as $\hslot = H(b, r)$, where  $r$ is a unique nonce and $b$ marks the location as water/ship. 
Each cell is a leaf in a merkle tree and the root is stored in the contract. 

\paragraph{Opening a slot} 

During the game, the counterparty must open the cell $b,r$ alongside a merkle tree branch to prove that this cell is included in the board. 

\paragraph{Keeping track of hits} The contract can maintain a bit string, and flip a bit every time a specific cell is hit. This can prevent a player hitting the same slot twice. A second bit string can be used to indicate if a slot was marked as "water" or "hit". i.e. look up to see if cell was hit, and then check if it was 0/1 (i.e. water/ship location). 

\paragraph{Benefits and Problems} Prevents players lying during the game (assuming the board is well-formed due to probablistic check). However - it requires a merkle tree verification every move which can be expensive over-time. Also need to self-enforce that the cells and the ship locations match - so all should be revealed at the end of this game - that is a lot of information to send. (i.e. 100 random nonces, 100 b values, etc). 


\section{Extension to Battleship Contract}

To avoid the issue of allowing a player to "dos" by lying during the game - we can require the party to commit to every slot on the board. 

root + 7 hashes + 2 + opening. something along those lines. 

(could be merkle tree or just store every slot explicitly) - point is that proof of openin is required. can no longer lie about slot opening, but is it worth the overhead? 

- This prevents loser wasting turns - if they know they are going to lose, theyll simply not reveal their slots correctly and make the winner take up all their turns. 

\section{Security Analysis for Battleship Game}


\begin{figure}[h]
	\begin{boxedminipage}{\columnwidth}
		\begin{center}
			\textsf{State channel contract}{}\\
		\end{center}
		
		$\chanstatus := \bot \\
		\participant  := \emptyset, \appcontract := \bot, \\ \hstate := \bot, \monotoniccounter := 0 \\ \timerdispute := 0, \timenow := 0, \timeend := 0$
		
		\begin{flushleft}
			\constructor($\participant', \timerdispute', \appcontract'$):
			
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{set} $\participant := \participant'$ \\
			\quad \textbf{set} $\timerdispute := \timerdispute'$ \\ 
			\quad \textbf{set} $\appcontract := \appcontract'$ \\
			\quad \textbf{set} $\chanstatus := \chanon$ \\
			
		\end{tabular}
		
		\begin{flushleft}
			\oninput \stringlitt{triggerdispute}($\sigma_{k}$): 
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\chanstatus \neq \chanon$ \\
			\quad \textbf{discard if} $\participant \notin \participant_{k}$ \\
			\quad \textbf{if} $\verifysig(\participant_{k}, (\statechannel, \appcontract, ``\mathsf{dispute}"), \sigma_{k})$ \\
			\quad \quad \textbf{set} $\chanstatus := \chandispute$ \\
			\quad \quad \textbf{set} $\timestart := \timenow$ \\
			\quad \quad \textbf{set} $\timedispute := \timestart + \timerdispute$
			
		\end{tabular}
		
		
		\begin{flushleft}
			\oninput  \stringlitt{setstatehash}($\hstate', \monotoniccounter', \Sigma_{\participant}$):
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\chanstatus = \chanoff$ \\
			\quad \textbf{discard if} $\monotoniccounter' \leq \monotoniccounter$ \\
			\quad \textbf{if} $\verifysig(\participant, (\hstate', \monotoniccounter', \statechannel, \appcontract), \Sigma_{\participant})$ \\
			\quad \quad \textbf{set} $\hstate := \hstate'$ \\
			\quad \quad \textbf{set} $\monotoniccounter := \monotoniccounter'$ \\
		\end{tabular}
		
		\begin{flushleft} 
			\oninput \stringlitt{resolve}(): 
		\end{flushleft}
		\begin{tabular}{l}
		\quad \textbf{discard if} $\chanstatus \neq \chandispute$ \\
		\quad \textbf{discard if} $\timenow < \timeend$ \\
		\quad \textbf{set} $\chanstatus := \chanoff$ 
		\end{tabular}
	
		\begin{flushleft} 
		\oninput \stringlitt{getstatehash}(): 
		\end{flushleft}
		\begin{tabular}{l}
		\quad \textbf{discard if} $\chanstatus \neq \chanoff$ \\
		\quad \textbf{return} $\hstatei$
		\end{tabular}
		
		\begin{flushleft} 
			\oninput \stringlitt{getdispute}(): 
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\chanstatus \neq \chanoff$ \\
			\quad \textbf{return} $(\timenow, \timeend, \monotoniccounter)$
		\end{tabular}
	\end{boxedminipage}
	\caption{The state channel contract. It is responsible for managing the dispute process and determining the final state hash.  Discard fails the transaction execution if the pre-condition is satisfied.} \label{fig:statechannel}
\end{figure}

\begin{figure}
\begin{boxedminipage}{\columnwidth}
	\begin{center}
		\textsf{Template for application contract}{}\\
	\end{center}
	
	$\instantiated := \bot,  \stateinfo := \bot \\ 
	\participant  := \emptyset,  \timerdispute := 0, \\
	\statechannel := \bot, \mathsf{k} := 0$
	
		
	\begin{flushleft}
		\constructor($\participant'$): 
	\end{flushleft}
	\begin{tabular}{l}
		\quad \textbf{set} $\participant := \participant'$ \\
		\quad \textbf{set} $\instantiated := \instantiatedno$ \\
		
	\end{tabular}

	\begin{flushleft}
		\oninput \stringlitt{example}(): 
	\end{flushleft}
	\begin{tabular}{l}
		\quad \textbf{discard if} $\instantiated = \instantiatedyes$ \\
		\quad \_;
		
	\end{tabular}
	
	
	\begin{flushleft}
		\oninput  \stringlitt{lock}($\timerdispute', \Sigma_{\participant}$):
	\end{flushleft}
	\begin{tabular}{l}
		\quad \textbf{discard if} $\instantiated = \instantiatedyes$ \\
		\quad \textbf{if} $\verifysig(\participant,(``\mathsf{instantiate}", \appcontract, \mathsf{k}),\Sigma_{\participant})$ \\
		\quad \quad \textbf{set} $\instantiated := \instantiatedyes$ \\
		\quad \quad \textbf{set} $\mathsf{k} := \mathsf{k} + 1$ \\
		\quad \quad \textbf{set} $\statechannel := \mathsf{StateChannel}(\participant, \timerdispute, \mathsf{this})$
	\end{tabular}
	
	\begin{flushleft} 
		\oninput \stringlitt{unlock}($\stateinfo',\ran'$): 
	\end{flushleft}
	\begin{tabular}{l}
		\quad \textbf{discard if} $\instantiated = \instantiatedno$ \\
		\quad \textbf{if} $\hash(\stateinfo', \ran') = \statechannelgetcommitment()$ \\
		\quad \quad $\instantiated := \instantiatedno$ \\
		\quad \quad $\stateinfo := \stateinfo'$ \\
		\quad \textbf{else if} $\bot = \statechannelgetcommitment()$  \\
		\quad \quad $\instantiated := \instantiatedno$
	\end{tabular}
\end{boxedminipage}

	\caption{The application contract template. The above modifications must be included to support a state channel. It allows all functionality to be disabled when the channel is created and re-enables all functionality after the dispute process when provided with the full state.}\label{fig:appmodify}
\end{figure}


\begin{figure}[h]
	\begin{boxedminipage}{\columnwidth}
		\begin{center}
			\textsf{BattleshipCon1}{}\\
		\end{center}
		
		$\instantiated := \bot, \statechannel := \bot,	\participant  := \emptyset \\ 
		 \timestart := 0, \timeend := 0,, \timerchallenge := 0, \timerdispute := 0$ \\
		$\textsf{struct ship} \{(i,j),(i',j'),k, r\}, \mathsf{ship}[6]$ \\
	    $\textsf{struct slot} \{b, r\}, \mathsf{slot}[10][10]$ \\
	    $\hslot[10][10], \hship[6]$ \\
		$\gamestatus := \gamesetup, \textsf{turn} := \bot$
		
		\begin{flushleft}
			\constructor($\participant', \timerdispute', \timerchallenge$):
			
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{set} $\participant := \participant'$ \\
			\quad \textbf{set} $\timerdispute := \timerdispute'$ \\ 
			\quad \textbf{set} $\timerdispute:= \timerchallenge$ \\ 
			
		\end{tabular}
		
		\begin{flushleft}
			\oninput \stringlitt{select}($\sigma_{\participant}, \hslot[10,10], k[6], \hship[6]$): 
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\instantiated = \instantiatedyes$ \\
			\quad \textbf{if} $\verifysig(\sigma_{\participant},\hslot[0,0],...,\hslot[10,10],(k[1],\hship[1]),...,(k[n],\hship[n]),\participant)$ \\
			
		\end{tabular}
		
		
		\begin{flushleft}
			\oninput  \stringlitt{begingame}($\hstate', \monotoniccounter', \Sigma_{\participant}$):
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\instantiated = \instantiatedyes$ \\
		\end{tabular}
		
		\begin{flushleft} 
			\oninput \stringlitt{resolve}(): 
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\chanstatus \neq \chandispute$ \\
			\quad \textbf{discard if} $\timenow < \timeend$ \\
			\quad \textbf{set} $\chanstatus := \chanoff$ 
		\end{tabular}
		
		\begin{flushleft} 
			\oninput \stringlitt{getstatehash}(): 
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\chanstatus \neq \chanoff$ \\
			\quad \textbf{return} $\hstatei$
		\end{tabular}
		
		\begin{flushleft} 
			\oninput \stringlitt{getdispute}(): 
		\end{flushleft}
		\begin{tabular}{l}
			\quad \textbf{discard if} $\chanstatus \neq \chanoff$ \\
			\quad \textbf{return} $(\timenow, \timeend, \monotoniccounter)$
		\end{tabular}
	\end{boxedminipage}
	\caption{The state channel contract. It is responsible for managing the dispute process and determining the final state hash.  Discard fails the transaction execution if the pre-condition is satisfied.} \label{fig:statechannel}
\end{figure}


\end{document}
